/*******************************************************************************
 * Copyright (c) Faktor Zehn GmbH - faktorzehn.org
 * 
 * This source code is available under the terms of the AGPL Affero General Public License version
 * 3.
 * 
 * Please see LICENSE.txt for full license terms, including the additional permissions and
 * restrictions as well as the possibility of alternative license terms.
 *******************************************************************************/

package org.faktorips.devtools.model.builder;

import static org.faktorips.devtools.abstraction.Wrappers.unwrap;
import static org.faktorips.devtools.abstraction.Wrappers.wrap;
import static org.faktorips.devtools.abstraction.mapping.BuildKindMapping.buildKind;
import static org.faktorips.devtools.abstraction.mapping.PathMapping.toEclipsePath;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubMonitor;
import org.faktorips.devtools.abstraction.ABuildKind;
import org.faktorips.devtools.abstraction.ABuilder;
import org.faktorips.devtools.abstraction.AFile;
import org.faktorips.devtools.abstraction.AFolder;
import org.faktorips.devtools.abstraction.AMarker;
import org.faktorips.devtools.abstraction.APackageFragmentRoot;
import org.faktorips.devtools.abstraction.AProject;
import org.faktorips.devtools.abstraction.AResource;
import org.faktorips.devtools.abstraction.AResource.AResourceTreeTraversalDepth;
import org.faktorips.devtools.abstraction.AResourceDelta;
import org.faktorips.devtools.abstraction.AResourceDeltaVisitor;
import org.faktorips.devtools.abstraction.exception.IpsException;
import org.faktorips.devtools.model.IIpsElement;
import org.faktorips.devtools.model.IIpsModel;
import org.faktorips.devtools.model.IIpsModelExtensions;
import org.faktorips.devtools.model.dependency.IDependency;
import org.faktorips.devtools.model.internal.builder.DependencyResolver;
import org.faktorips.devtools.model.internal.ipsobject.IpsSrcFile;
import org.faktorips.devtools.model.internal.ipsproject.IpsBundleManifest;
import org.faktorips.devtools.model.ipsobject.IIpsObject;
import org.faktorips.devtools.model.ipsobject.IIpsSrcFile;
import org.faktorips.devtools.model.ipsobject.QualifiedNameType;
import org.faktorips.devtools.model.ipsproject.IIpsArchiveEntry;
import org.faktorips.devtools.model.ipsproject.IIpsArtefactBuilder;
import org.faktorips.devtools.model.ipsproject.IIpsArtefactBuilderSet;
import org.faktorips.devtools.model.ipsproject.IIpsObjectPath;
import org.faktorips.devtools.model.ipsproject.IIpsObjectPathContainer;
import org.faktorips.devtools.model.ipsproject.IIpsObjectPathEntry;
import org.faktorips.devtools.model.ipsproject.IIpsPackageFragment;
import org.faktorips.devtools.model.ipsproject.IIpsPackageFragmentRoot;
import org.faktorips.devtools.model.ipsproject.IIpsProject;
import org.faktorips.devtools.model.ipsproject.IIpsSrcFolderEntry;
import org.faktorips.devtools.model.plugin.IpsLog;
import org.faktorips.devtools.model.plugin.IpsModelActivator;
import org.faktorips.devtools.model.plugin.IpsStatus;
import org.faktorips.runtime.Message;
import org.faktorips.runtime.MessageList;
import org.faktorips.runtime.ObjectProperty;
import org.faktorips.runtime.Severity;
import org.faktorips.util.MultiMap;

/**
 * The IPS builder generates Java sourcecode and XML files based on the IPS objects contained in the
 * IPS project. It runs before the Java builder, so that first the Java sourcecode is generated by
 * the IPS builder and then the Java builder compiles the Java sourcecode into class files.
 */
public class IpsBuilder {

    /**
     * The builders extension id.
     */
    public static final String BUILDER_ID = IpsModelActivator.PLUGIN_ID + ".ipsbuilder"; //$NON-NLS-1$

    public static final String PROBLEM_MARKER = IpsModelActivator.PLUGIN_ID + ".problemmarker"; //$NON-NLS-1$

    public static final boolean TRACE_BUILDER_TRACE;

    private final ABuilder builder;

    static {
        TRACE_BUILDER_TRACE = Boolean
                .parseBoolean(Platform.getDebugOption("org.faktorips.devtools.model/trace/builder"));
    }

    /**
     * The key is the name of the IpsProject, the value the last modification time stamp of the
     * IpsProjectProperties from the last build.
     */
    private Map<String, Long> lastModificationTimestampForBuilderSets = new HashMap<>();

    public IpsBuilder(ABuilder builder) {
        super();
        this.builder = builder;
    }

    private MultiStatus createInitialMultiStatus() {
        return new MultiStatus(IpsModelActivator.PLUGIN_ID, 0, Messages.IpsBuilder_msgBuildResults, null);
    }

    protected Set<AProject> build(ABuildKind kind, IProgressMonitor monitor) {
        ABuildKind currentKind = kind;
        MultiStatus buildStatus = createInitialMultiStatus();
        try {
            SubMonitor subMonitor = SubMonitor.convert(monitor, "build", 100000); //$NON-NLS-1$
            subMonitor.subTask(Messages.IpsBuilder_validatingProject);
            /*
             * We have to clear the validation cache as for example the deletion of IPS source files
             * might still be undetected as the validation result cache gets cleared in a resource
             * change listener. it is not guaranteed that the listener is notified before the build
             * starts!
             */
            getIpsProject().getIpsModel().clearValidationCache();
            if (!checkIpsProjectBeforeBuild(getIpsProject())) {
                return null;
            }
            subMonitor.worked(100);
            subMonitor.subTask(Messages.IpsBuilder_preparingBuild);
            IIpsArtefactBuilderSet ipsArtefactBuilderSet = getBuilderSetReInitialisedIfNecessary(getIpsProject());
            boolean isFullBuildRequired = isFullBuildRequired(currentKind);
            if (isFullBuildRequired) {
                currentKind = ABuildKind.FULL;
            }
            beforeBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, currentKind);
            applyBuildCommand(ipsArtefactBuilderSet, buildStatus,
                    new BeforeBuildProcessCommand(currentKind, getIpsProject()), subMonitor);
            subMonitor.worked(100);
            try {
                if (isFullBuildRequired) {
                    currentKind = ABuildKind.FULL;
                    subMonitor.subTask(Messages.IpsBuilder_startFullBuild);
                    fullBuild(ipsArtefactBuilderSet, buildStatus, subMonitor.split(9970));
                } else {
                    subMonitor.subTask(Messages.IpsBuilder_startIncrementalBuild);
                    incrementalBuild(ipsArtefactBuilderSet, buildStatus, subMonitor.split(9970));
                }
            } finally {
                subMonitor.subTask(Messages.IpsBuilder_finishBuild);
                applyBuildCommand(ipsArtefactBuilderSet, buildStatus,
                        new AfterBuildProcessCommand(currentKind, getIpsProject()), subMonitor);
                afterBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, currentKind);
            }
            subMonitor.worked(100);
            if (buildStatus.getSeverity() == IStatus.OK) {
                return builder.getProject().getReferencedProjects();
            }

            printBuildExceptionMessages(buildStatus);

            // Re-initialize the builders of the current builder set if an error occurs.
            getIpsProject().reinitializeIpsArtefactBuilderSet();

            throw new CoreException(buildStatus);

        } catch (OperationCanceledException e) {
            getIpsProject().reinitializeIpsArtefactBuilderSet();
        } catch (CoreException e) {
            throw new IpsException(e);
            // CSOFF: IllegalCatch
        } catch (Throwable t) {
            /*
             * Need to catch Throwable. If the incremental project builder throws an error, Eclipse
             * just writes a Warning to the error log. So we wrap the error into a CoreException.
             */
            throw new IpsException(new IpsStatus(t));
        }
        // CSON: IllegalCatch
        return builder.getProject().getReferencedProjects();
    }

    private void printBuildExceptionMessages(MultiStatus buildStatus) {
        IStatus[] builds = buildStatus.getChildren();
        for (IStatus build : builds) {
            IStatus[] buildResults = build.getChildren();
            for (IStatus buildResult : buildResults) {
                Throwable exception = buildResult.getException();
                if (exception != null) {
                    System.out.println("ERROR: " + exception.getMessage()); //$NON-NLS-1$
                }
            }
        }
    }

    private IIpsArtefactBuilderSet getBuilderSetReInitialisedIfNecessary(IIpsProject project) {
        Long timestamp = lastModificationTimestampForBuilderSets.get(project.getName());
        if (timestamp == null) {
            lastModificationTimestampForBuilderSets.put(project.getName(),
                    project.getReadOnlyProperties().getLastPersistentModificationTimestamp());
            return project.getIpsArtefactBuilderSet();
        }

        Long projectTimestamp = project.getReadOnlyProperties().getLastPersistentModificationTimestamp();
        if (!timestamp.equals(projectTimestamp)) {
            project.reinitializeIpsArtefactBuilderSet();
            lastModificationTimestampForBuilderSets.put(project.getName(), projectTimestamp);
        }
        return project.getIpsArtefactBuilderSet();
    }

    private boolean checkIpsProjectBeforeBuild(IIpsProject ipsProject) {
        ipsProject.getProject().deleteMarkers(IpsBuilder.PROBLEM_MARKER, true,
                AResourceTreeTraversalDepth.RESOURCE_ONLY);
        try {
            MessageList list = ipsProject.validate();
            AResource markedResource = ipsProject.getIpsProjectPropertiesFile();
            if (!markedResource.exists()) {
                markedResource = ipsProject.getProject();
                createMarkersFromMessageList(markedResource, list, IpsBuilder.PROBLEM_MARKER);
            } else {
                createMarkersForIpsProjectProperties(list, ipsProject);
            }

            if (list.containsErrorMsg()) {
                AMarker marker = markedResource.createMarker(IpsBuilder.PROBLEM_MARKER);
                String msg = Messages.IpsBuilder_msgInvalidProperties;
                updateMarker(marker, msg, IMarker.SEVERITY_ERROR);
                return false;
            }
        } catch (IpsException e) {
            IpsLog.log(e);
            return false;
        }
        return true;
    }

    /**
     * creates markers for the messages from the validation of the ipsproject differing between the
     * .ipsproject and manifest.mf as marked resource.
     */
    void createMarkersForIpsProjectProperties(MessageList messages, IIpsProject ipsProject) {
        AResource projectPropertiesFile = ipsProject.getIpsProjectPropertiesFile();
        IIpsObjectPath ipsObjectPath = ipsProject.getReadOnlyProperties().getIpsObjectPath();

        AFile manifest = ipsProject.getProject().getFile(IpsBundleManifest.MANIFEST_NAME);

        if (ipsObjectPath.isUsingManifest()) {
            if (manifest.exists()) {
                createMarkersForIpsProjectPropertiesAndManifest(messages, projectPropertiesFile, manifest);
            } else {
                createMarkersWithMissingManifestMarker(messages, projectPropertiesFile);
            }
        } else {
            createMarkersNotUsingManifest(messages, projectPropertiesFile, manifest);
        }
    }

    private void createMarkersNotUsingManifest(MessageList messages, AResource projectPropertiesFile, AFile manifest) {
        createMarkersFromMessageList(projectPropertiesFile, messages, IpsBuilder.PROBLEM_MARKER);

        if (manifest.exists()) {
            manifest.deleteMarkers(IpsBuilder.PROBLEM_MARKER, true, AResourceTreeTraversalDepth.RESOURCE_ONLY);
        }
    }

    private void createMarkersWithMissingManifestMarker(MessageList messages, AResource projectPropertiesFile) {
        createMarkersFromMessageList(projectPropertiesFile, messages, IpsBuilder.PROBLEM_MARKER);

        AMarker marker = projectPropertiesFile.createMarker(IpsBuilder.PROBLEM_MARKER);
        String msg = MessageFormat.format(Messages.IpsBuilder_missingManifestMf, IpsBundleManifest.MANIFEST_NAME);
        updateMarker(marker, msg, IMarker.SEVERITY_ERROR);
    }

    private void createMarkersForIpsProjectPropertiesAndManifest(MessageList messages,
            AResource projectPropertiesFile,
            AFile manifest) {
        MessageList messagesIpsObjectPath = new MessageList();
        MessageList messagesProject = new MessageList();

        for (Message message : messages) {
            if (isRelateToIpsObjectPath(message)) {
                messagesIpsObjectPath.add(message);
            } else {
                messagesProject.add(message);
            }
        }

        createMarkersFromMessageList(projectPropertiesFile, messagesProject, IpsBuilder.PROBLEM_MARKER);
        createMarkersFromMessageList(manifest, messagesIpsObjectPath, IpsBuilder.PROBLEM_MARKER);
    }

    private boolean isRelateToIpsObjectPath(Message message) {
        List<ObjectProperty> objectProperties = message.getInvalidObjectProperties();
        for (ObjectProperty objectProperty : objectProperties) {
            Object object = objectProperty.getObject();
            if (object instanceof IIpsObjectPath || object instanceof IIpsObjectPathEntry
                    || object instanceof IIpsObjectPathContainer) {
                return true;
            }
        }
        return false;
    }

    private boolean isFullBuildRequired(ABuildKind currentKind) {
        if (currentKind == ABuildKind.FULL) {
            return true;
        }
        AResourceDelta delta = builder.getDelta();
        if (delta == null) {
            return true;
        }
        IIpsProject ipsProject = getIpsProject();
        if ((delta
                .findMember(toEclipsePath(ipsProject.getIpsProjectPropertiesFile().getProjectRelativePath())) != null)
                || (delta.findMember(new Path(IpsBundleManifest.MANIFEST_NAME)) != null)) {
            return true;
        }
        IIpsArchiveEntry[] entries = ipsProject.getReadOnlyProperties().getIpsObjectPath().getArchiveEntries();
        for (IIpsArchiveEntry entry : entries) {
            if (entry.isAffectedBy(delta)) {
                return true;
            }
        }
        return false;
    }

    private boolean isBuilderEnabled() {
        return IIpsModelExtensions.get().getModelPreferences().isBuilderEnabled();
    }

    private void beforeBuildForBuilderSet(IIpsArtefactBuilderSet builderSet,
            MultiStatus buildStatus,
            ABuildKind buildKind) {
        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!isBuilderEnabled()) {
            return;
        }
        try {
            builderSet.beforeBuildProcess(buildKind);
            // CSOFF: IllegalCatch
        } catch (Exception e) {
            buildStatus.add(
                    new IpsStatus("Error during beforeBuildProcess() of the builder set: " + builderSet.getId(), e)); //$NON-NLS-1$
        }
        // CSON: IllegalCatch
    }

    private void afterBuildForBuilderSet(IIpsArtefactBuilderSet builderSet,
            MultiStatus buildStatus,
            ABuildKind buildKind) {
        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!isBuilderEnabled()) {
            return;
        }
        try {
            builderSet.afterBuildProcess(buildKind);
            // CSOFF: IllegalCatch
        } catch (Exception e) {
            buildStatus.add(new IpsStatus("Error during afterBuildProcess() of the builder set: " + builderSet.getId(), //$NON-NLS-1$
                    e));
        }
        // CSON: IllegalCatch
    }

    private void applyBuildCommand(IIpsArtefactBuilderSet currentBuilderSet,
            MultiStatus buildStatus,
            BuildCommand command,
            IProgressMonitor monitor) {

        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!isBuilderEnabled()) {
            return;
        }
        IIpsArtefactBuilder[] artefactBuilders = currentBuilderSet.getArtefactBuilders();
        for (IIpsArtefactBuilder artefactBuilder : artefactBuilders) {
            try {
                command.build(artefactBuilder, buildStatus);
                // CSOFF: IllegalCatch
            } catch (Exception e) {
                addIpsStatus(artefactBuilder, command, buildStatus, e);
            }
            // CSON: IllegalCatch
        }
        if (monitor.isCanceled()) {
            throw new OperationCanceledException();
        }
    }

    private void addIpsStatus(IIpsArtefactBuilder builder, BuildCommand command, MultiStatus buildStatus, Exception e) {
        String text = builder.getName() + ": Error during: " + command + "."; //$NON-NLS-1$ //$NON-NLS-2$
        buildStatus.add(new IpsStatus(text, e));
    }

    private IDependencyGraph getDependencyGraph(IIpsProject ipsProject) {
        return ipsProject.getDependencyGraph();
    }

    /**
     * Returns the IPS project the build is currently building.
     */
    private IIpsProject getIpsProject() {
        // need null check because builder sometimes still running when shutdown platform and
        // IpsModel is already down
        if (IIpsModel.get() != null) {
            return IIpsModel.get().getIpsProject(builder.getProject());
        } else {
            return null;
        }
    }

    private void collectIpsSrcFilesForFullBuild(List<IIpsSrcFile> allIpsSrcFiles) {
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (IIpsPackageFragmentRoot root : roots) {
            if (!root.isBasedOnSourceFolder()) {
                continue;
            }
            IIpsPackageFragment[] packs = root.getIpsPackageFragments();
            for (IIpsPackageFragment pack : packs) {
                IIpsElement[] elements = pack.getChildren();
                for (IIpsElement element : elements) {
                    if (element instanceof IIpsSrcFile) {
                        allIpsSrcFiles.add((IIpsSrcFile)element);
                    }
                }
            }
        }
    }

    private void removeEmptyFolders() {
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (IIpsPackageFragmentRoot root : roots) {
            if (root.isBasedOnSourceFolder()) {
                removeEmptyFolders((AFolder)root.getArtefactDestination(false).getResource(), false);
            }
        }
    }

    /**
     * Full build generates Java source files for all IPS objects.
     */
    private MultiStatus fullBuild(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor) {
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Full build started."); //$NON-NLS-1$
        }
        long begin = System.currentTimeMillis();

        try {
            List<IIpsSrcFile> allIpsSrcFiles = new ArrayList<>();
            collectIpsSrcFilesForFullBuild(allIpsSrcFiles);
            monitor.beginTask("full build", 2 * allIpsSrcFiles.size()); //$NON-NLS-1$
            getDependencyGraph(getIpsProject()).reInit();
            monitor.worked(allIpsSrcFiles.size());
            removeEmptyFolders();

            for (IIpsSrcFile ipsSrcFile : allIpsSrcFiles) {
                if (monitor.isCanceled()) {
                    break;
                }
                try {
                    monitor.subTask(Messages.IpsBuilder_building + ipsSrcFile.getName());
                    buildIpsSrcFile(ipsArtefactBuilderSet, getIpsProject(), ipsSrcFile, buildStatus, monitor);
                    monitor.worked(1);
                    // CSOFF: IllegalCatch
                } catch (Exception e) {
                    buildStatus.add(new IpsStatus(e));
                }
                // CSON: IllegalCatch
            }
        } catch (IpsException e) {
            buildStatus.add(new IpsStatus(e));
        } finally {
            monitor.done();
        }
        long end = System.currentTimeMillis();
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Full build finished. Duration: " + (end - begin)); //$NON-NLS-1$
        }
        return buildStatus;
    }

    protected void clean(IProgressMonitor monitor) {
        getIpsProject().clearCaches();
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (IIpsPackageFragmentRoot root : roots) {
            if (monitor.isCanceled()) {
                return;
            }
            if (!root.isBasedOnSourceFolder()) {
                continue;
            }
            APackageFragmentRoot destination = root.getArtefactDestination(true);
            if (destination == null) {
                continue;
            }
            if (destination.exists()) {
                removeDerivedResources((AFolder)destination.getResource(), monitor);
            }
        }
        getBuilderSetReInitialisedIfNecessary(getIpsProject()).clean(monitor);
    }

    /**
     * Only the resource (file, folder) that is actually derived will be deleted. So if a user
     * chooses to place a non derived resource in the destination folder it will not be deleted.
     * Accordingly all folders in the folder hierarchy starting from the folder that contains the
     * derived resource will not be deleted.
     */
    private void removeDerivedResources(AFolder folder, IProgressMonitor monitor) {
        for (AResource member : folder) {
            if (monitor.isCanceled()) {
                return;
            }
            if (member.exists()) {
                if (member.getType() == AResource.AResourceType.FILE && member.isDerived()) {
                    member.delete(monitor);
                    continue;
                }
                if (member.getType() == AResource.AResourceType.FOLDER) {
                    AFolder folderMember = (AFolder)member;
                    removeDerivedResources(folderMember, monitor);
                    if (folderMember.getMembers().size() == 0 && folderMember.isDerived()) {
                        folderMember.delete(monitor);
                    }
                }
            }
        }
    }

    private void removeEmptyFolders(AFolder parent, boolean removeThisParent) {
        if (parent == null || !parent.exists()) {
            return;
        }
        SortedSet<? extends AResource> members = parent.getMembers();
        if (removeThisParent && members.size() == 0) {
            parent.delete(null);
            return;
        }
        for (AResource member : members) {
            if (member.getType() == AResource.AResourceType.FOLDER) {
                removeEmptyFolders((AFolder)member, true);
            }
        }
    }

    /**
     * Incremental build generates Java source files for all PdObjects that have been changed.
     */
    private void incrementalBuild(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor) {
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Incremental build started."); //$NON-NLS-1$
        }

        try {
            AResourceDelta delta = builder.getDelta();
            IncBuildVisitor visitor = new IncBuildVisitor(getIpsProject());
            delta.accept(visitor);
            DependencyResolver dependencyResolver = new DependencyResolver(getIpsProject());
            MultiMap<IIpsProject, IDependency> dependenciesForProjectsMap = dependencyResolver
                    .collectDependenciesForIncrementalBuild(visitor.changedAndAddedIpsSrcFiles,
                            visitor.removedIpsSrcFiles);
            int numberOfBuildCandidates = dependenciesForProjectsMap.count() + visitor.removedIpsSrcFiles.size()
                    + visitor.changedAndAddedIpsSrcFiles.size();
            monitor.beginTask("build incremental", numberOfBuildCandidates); //$NON-NLS-1$
            buildRemovedIpsSrcFiles(ipsArtefactBuilderSet, buildStatus, monitor, visitor);

            buildChangedAndAddedIpsSrcFiles(ipsArtefactBuilderSet, buildStatus, monitor, visitor);

            buildDependeningProjects(buildStatus, monitor, dependenciesForProjectsMap);
            // CSOFF: IllegalCatch
        } catch (Exception e) {
            buildStatus.add(new IpsStatus(e));
            // CSON: IllegalCatch
        } finally {
            monitor.done();
            if (TRACE_BUILDER_TRACE) {
                System.out.println("Incremental build finished."); //$NON-NLS-1$
            }
        }
    }

    private void buildDependeningProjects(MultiStatus buildStatus,
            IProgressMonitor monitor,
            MultiMap<IIpsProject, IDependency> dependenciesForProjectsMap) {
        for (IIpsProject ipsProject : dependenciesForProjectsMap.keySet()) {
            if (monitor.isCanceled()) {
                break;
            }
            if (!ipsProject.equals(getIpsProject())) {
                if (!checkIpsProjectBeforeBuild(ipsProject)) {
                    continue;
                }
            }
            Collection<IDependency> dependencySet = dependenciesForProjectsMap.get(ipsProject);

            /*
             * Dependent IPS object can be located in a different project which can have a different
             * artefact builder set therefore the builder set needs to be determined for each
             * project at this point.
             */
            IIpsArtefactBuilderSet projectIpsArtefactBuilderSet = getBuilderSetReInitialisedIfNecessary(ipsProject);
            Set<QualifiedNameType> alreadyBuild = new HashSet<>(dependencySet.size());
            MultiStatus currentBuildStatus = createInitialMultiStatus();
            try {
                if (!ipsProject.equals(getIpsProject())) {
                    beforeBuildForBuilderSet(projectIpsArtefactBuilderSet, buildStatus, ABuildKind.INCREMENTAL);
                    applyBuildCommand(projectIpsArtefactBuilderSet, currentBuildStatus,
                            new BeforeBuildProcessCommand(ABuildKind.INCREMENTAL, ipsProject), monitor);
                }
                buildDependencies(monitor, ipsProject, dependencySet, projectIpsArtefactBuilderSet, alreadyBuild,
                        currentBuildStatus);
                // CSOFF: IllegalCatch
            } catch (Exception e) {
                currentBuildStatus.add(new IpsStatus(IStatus.ERROR, MessageFormat.format(
                        Messages.IpsBuilder_msgExceptionWhileBuildingDependentProjects, ipsProject.getName()), e));
                // CSON: IllegalCatch
            } finally {
                if (!ipsProject.equals(getIpsProject())) {
                    applyBuildCommand(projectIpsArtefactBuilderSet, currentBuildStatus,
                            new AfterBuildProcessCommand(ABuildKind.INCREMENTAL, ipsProject), monitor);
                    afterBuildForBuilderSet(projectIpsArtefactBuilderSet, buildStatus, ABuildKind.INCREMENTAL);
                    if (currentBuildStatus.getSeverity() != IStatus.OK) {
                        ipsProject.reinitializeIpsArtefactBuilderSet();
                    }
                }
            }
            if (!currentBuildStatus.isOK()) {
                buildStatus.add(currentBuildStatus);
            }
        }
    }

    private void buildDependencies(IProgressMonitor monitor,
            IIpsProject ipsProject,
            Collection<IDependency> dependencySet,
            IIpsArtefactBuilderSet projectIpsArtefactBuilderSet,
            Set<QualifiedNameType> alreadyBuild,
            MultiStatus currentBuildStatus) {
        for (IDependency dependency : dependencySet) {
            if (monitor.isCanceled()) {
                break;
            }
            QualifiedNameType buildCandidateId = dependency.getSource();
            if (alreadyBuild.contains(buildCandidateId)) {
                continue;
            }
            alreadyBuild.add(buildCandidateId);
            IIpsObject ipsObject = ipsProject.findIpsObject(buildCandidateId);
            if (ipsObject == null) {
                continue;
            }
            monitor.subTask(Messages.IpsBuilder_building + dependency);
            buildIpsSrcFile(projectIpsArtefactBuilderSet, ipsProject, ipsObject.getIpsSrcFile(),
                    currentBuildStatus, monitor);
            updateDependencyGraph(ipsObject.getIpsSrcFile());
            monitor.worked(1);
        }
    }

    private void buildChangedAndAddedIpsSrcFiles(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor,
            IncBuildVisitor visitor) {
        for (IIpsSrcFile iIpsSrcFile : visitor.changedAndAddedIpsSrcFiles) {
            if (monitor.isCanceled()) {
                break;
            }
            IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
            monitor.subTask(Messages.IpsBuilder_building + ipsSrcFile.getName());
            buildIpsSrcFile(ipsArtefactBuilderSet, getIpsProject(), ipsSrcFile, buildStatus, monitor);
            updateDependencyGraph(ipsSrcFile);
            monitor.worked(1);
        }
    }

    private void buildRemovedIpsSrcFiles(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor,
            IncBuildVisitor visitor) {
        for (IIpsSrcFile iIpsSrcFile : visitor.removedIpsSrcFiles) {
            if (monitor.isCanceled()) {
                break;
            }
            IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
            monitor.subTask(Messages.IpsBuilder_deleting + ipsSrcFile.getName());
            applyBuildCommand(ipsArtefactBuilderSet, buildStatus, new DeleteArtefactBuildCommand(ipsSrcFile),
                    monitor);
            updateDependencyGraph(ipsSrcFile);
            monitor.worked(1);
        }
    }

    private void updateMarkers(MultiStatus buildStatus, IIpsObject object) {
        if (object == null) {
            return;
        }
        AResource resource = object.getEnclosingResource();
        if (!resource.exists()) {
            return;
        }
        try {

            MessageList list = object.validate(object.getIpsProject());
            createMarkersFromMessageList(resource, list, IpsBuilder.PROBLEM_MARKER);
            // CSOFF: IllegalCatch
        } catch (Exception e) {
            buildStatus.add(new IpsStatus("An exception occurred during marker updating for " + object, e)); //$NON-NLS-1$
        }
        // CSON: IllegalCatch
    }

    void createMarkersFromMessageList(AResource markedResource, MessageList list, String markerType) {
        Set<AMarker> markers = new LinkedHashSet<>(
                markedResource.findMarkers(markerType, true, AResourceTreeTraversalDepth.RESOURCE_ONLY));
        for (int i = 0; i < list.size(); i++) {
            Message msg = list.getMessage(i);
            boolean foundMarked = false;
            for (Iterator<AMarker> iterator = markers.iterator(); iterator.hasNext();) {
                AMarker marker = iterator.next();
                String message = (String)marker.getAttribute(IMarker.MESSAGE);
                Integer severity = (Integer)marker.getAttribute(IMarker.SEVERITY);
                if (msg.getText().equals(message) && getMarkerSeverity(msg) == severity) {
                    foundMarked = true;
                    iterator.remove();
                    break;
                }
            }
            if (!foundMarked) {
                AMarker marker = markedResource.createMarker(markerType);
                updateMarker(marker, msg.getText(), getMarkerSeverity(msg));
            }
        }
        for (AMarker marker : markers) {
            marker.delete();
        }
    }

    private void updateMarker(AMarker marker, String text, int severity) {
        marker.setAttributes(new String[] { IMarker.MESSAGE, IMarker.SEVERITY },
                new Object[] { text, Integer.valueOf(severity) });
    }

    private int getMarkerSeverity(Message msg) {
        Severity msgSeverity = msg.getSeverity();
        if (msgSeverity == Severity.ERROR) {
            return IMarker.SEVERITY_ERROR;
        } else if (msgSeverity == Severity.WARNING) {
            return IMarker.SEVERITY_WARNING;
        } else if (msgSeverity == Severity.INFO) {
            return IMarker.SEVERITY_INFO;
        }
        throw new RuntimeException("Unknown severity " + msgSeverity); //$NON-NLS-1$
    }

    /**
     * Builds the indicated file and updates its markers.
     */
    private IIpsObject buildIpsSrcFile(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            IIpsProject ipsProject,
            IIpsSrcFile file,
            MultiStatus buildStatus,
            IProgressMonitor monitor) {

        if (!file.isContentParsable()) {
            // in case of error clear the markers
            file.getCorrespondingResource().deleteMarkers(IpsBuilder.PROBLEM_MARKER, false,
                    AResourceTreeTraversalDepth.RESOURCE_ONLY);

            for (String xsdError : file.getXsdValidationErrors()) {
                AMarker marker = file.getCorrespondingResource().createMarker(IpsBuilder.PROBLEM_MARKER);
                marker.setAttribute(IMarker.MESSAGE, xsdError);
                marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
            }

            AMarker marker = file.getCorrespondingResource().createMarker(IpsBuilder.PROBLEM_MARKER);
            marker.setAttribute(IMarker.MESSAGE, Messages.IpsBuilder_ipsSrcFileNotParsable);
            marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
            return null;
        }

        for (String xsdWarning : file.getXsdValidationWarnings()) {
            AMarker marker = file.getCorrespondingResource().createMarker(IpsBuilder.PROBLEM_MARKER);
            marker.setAttribute(IMarker.MESSAGE, xsdWarning);
            marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_WARNING);
        }

        IIpsObject ipsObject = file.getIpsObject();
        MultiStatus newStatus = createInitialMultiStatus();
        applyBuildCommand(ipsArtefactBuilderSet, newStatus, new BuildArtefactBuildCommand(file), monitor);
        if (!newStatus.isOK()) {
            fillMultiStatusWithMessageList(newStatus, ipsObject.validate(ipsProject));
            buildStatus.add(newStatus);
        }
        updateMarkers(buildStatus, ipsObject);
        return ipsObject;
    }

    private void fillMultiStatusWithMessageList(MultiStatus status, MessageList list) {
        for (int i = 0; i < list.size(); i++) {
            Message msg = list.getMessage(i);
            status.add(new IpsStatus(getMarkerSeverity(msg), msg.getText(), null));
        }
    }

    private void updateDependencyGraph(IIpsSrcFile ipsSrcFile) {
        getDependencyGraph(ipsSrcFile.getIpsProject()).update(ipsSrcFile.getQualifiedNameType());
    }

    /**
     * ResourceDeltaVisitor for the incremental build.
     */
    private static class IncBuildVisitor implements AResourceDeltaVisitor {

        private final IIpsSrcFolderEntry[] sourceFolderEntries;

        private List<IIpsSrcFile> removedIpsSrcFiles = new ArrayList<>(100);
        private List<IIpsSrcFile> changedAndAddedIpsSrcFiles = new ArrayList<>(100);

        private IncBuildVisitor(IIpsProject ipsProject) {
            sourceFolderEntries = ipsProject.getReadOnlyProperties().getIpsObjectPath().getSourceFolderEntries();
        }

        // CSOFF: CyclomaticComplexity
        @Override
        public boolean visit(AResourceDelta delta) {
            AResource resource = delta.getResource();
            if (resource == null || resource.getType() == AResource.AResourceType.PROJECT) {
                return true;
            }
            if (!isIpsResource(resource)) {
                return false;
            }

            // only interested in IpsSrcFile changes
            IIpsElement element = IIpsModel.get().getIpsElement(resource);
            if (!(element instanceof IIpsSrcFile)) {
                return true;
            }
            IIpsSrcFile ipsSrcFile = (IIpsSrcFile)element;
            switch (delta.getKind()) {
                case ADDED:
                    if (element.exists()) {
                        changedAndAddedIpsSrcFiles.add(ipsSrcFile);
                    }
                    return true;
                case REMOVED:
                    removedIpsSrcFiles.add(ipsSrcFile);
                    break;
                case CHANGED:
                    // skip changes, not caused by content changes,
                    if (delta.getFlags() != 0 && element.exists()) {
                        changedAndAddedIpsSrcFiles.add(ipsSrcFile);
                        return true;

                    }
                    break;
            }
            return true;
        }
        // CSON: CyclomaticComplexity

        /**
         * Checks if the provided resource is the java output folder resource or the IpsProject
         * output folder resource.
         */
        private boolean isIpsResource(AResource resource) {
            java.nio.file.Path resourceLocation = resource.getWorkspaceRelativePath();
            for (IIpsSrcFolderEntry srcFolderEntry : sourceFolderEntries) {
                if (resourceLocation.startsWith(srcFolderEntry.getSourceFolder().getWorkspaceRelativePath())) {
                    return true;
                }
            }
            return false;
        }
    }

    /**
     * The applyBuildCommand method of this class uses this interface.
     */
    private interface BuildCommand {
        void build(IIpsArtefactBuilder builder, MultiStatus status) throws IpsException;
    }

    private static class BeforeBuildProcessCommand implements BuildCommand {

        private ABuildKind buildKind;
        private IIpsProject ipsProject;

        public BeforeBuildProcessCommand(ABuildKind buildKind, IIpsProject ipsProject) {
            this.buildKind = buildKind;
            this.ipsProject = ipsProject;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) {
            if (TRACE_BUILDER_TRACE) {
                System.out.println("BeforeBuildProcessCommand, BuilderName: " //$NON-NLS-1$
                        + (builder != null ? builder.getName() : null) + " , BuilderObjectId: " //$NON-NLS-1$
                        + System.identityHashCode(builder) + ", Project name: " //$NON-NLS-1$
                        + (ipsProject != null ? ipsProject.getName() : null));
            }
            if (builder != null) {
                builder.beforeBuildProcess(ipsProject, buildKind);
            } else {
                throw new IpsException(
                        new Status(IStatus.ERROR, IpsModelActivator.PLUGIN_ID, "Builder is assert to be not null")); //$NON-NLS-1$
            }
        }

        @Override
        public String toString() {
            return "BeforeBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
        }

    }

    private static class AfterBuildProcessCommand implements BuildCommand {

        private ABuildKind buildKind;
        private IIpsProject ipsProject;

        public AfterBuildProcessCommand(ABuildKind buildKind, IIpsProject ipsProject) {
            this.buildKind = buildKind;
            this.ipsProject = ipsProject;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) {
            if (TRACE_BUILDER_TRACE) {
                System.out.println("AfterBuildProcessCommand, BuilderName: " //$NON-NLS-1$
                        + (builder != null ? builder.getName() : null) + " , BuilderObjectId: " //$NON-NLS-1$
                        + System.identityHashCode(builder) + ", Project name: " //$NON-NLS-1$
                        + (ipsProject != null ? ipsProject.getName() : null));
            }
            if (builder != null) {
                builder.afterBuildProcess(ipsProject, buildKind);
            } else {
                throw new IpsException(
                        new Status(IStatus.ERROR, IpsModelActivator.PLUGIN_ID, "Builder is assert to be not null")); //$NON-NLS-1$
            }
        }

        @Override
        public String toString() {
            return "AfterBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
        }
    }

    private static class BuildArtefactBuildCommand implements BuildCommand {

        private IIpsSrcFile ipsSrcFile;

        public BuildArtefactBuildCommand(IIpsSrcFile ipsSrcFile) {
            this.ipsSrcFile = ipsSrcFile;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) {
            if (builder.isBuilderFor(ipsSrcFile)) {
                long begin = 0;
                try {
                    if (TRACE_BUILDER_TRACE) {
                        begin = System.currentTimeMillis();
                        System.out.println(builder.getName() + ": Start building " + ipsSrcFile); //$NON-NLS-1$
                    }
                    builder.beforeBuild(ipsSrcFile, status);
                    builder.build(ipsSrcFile);
                } finally {
                    builder.afterBuild(ipsSrcFile);
                    if (TRACE_BUILDER_TRACE) {
                        System.out.println(builder.getName() + ": Finished building " + ipsSrcFile + ". Duration: " //$NON-NLS-1$ //$NON-NLS-2$
                                + (System.currentTimeMillis() - begin));
                    }
                }
            }
        }

        @Override
        public String toString() {
            return "Build file " + ipsSrcFile; //$NON-NLS-1$
        }
    }

    private static class DeleteArtefactBuildCommand implements BuildCommand {

        private IIpsSrcFile toDelete;

        public DeleteArtefactBuildCommand(IIpsSrcFile toDelete) {
            this.toDelete = toDelete;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) {
            if (builder.isBuilderFor(toDelete)) {
                builder.delete(toDelete);
            }
        }

        @Override
        public String toString() {
            return "Delete file " + toDelete; //$NON-NLS-1$
        }

    }

    public static class EclipseIpsBuilder extends IncrementalProjectBuilder {

        private final IpsBuilder ipsBuilder = new IpsBuilder(new EclipseBuilder());

        public IpsBuilder getIpsBuilder() {
            return ipsBuilder;
        }

        @Override
        protected IProject[] build(int kind, Map<String, String> args, IProgressMonitor monitor) {
            return unwrap(ipsBuilder.build(buildKind(kind), monitor)).asArrayOf(IProject.class);
        }

        @Override
        protected void clean(IProgressMonitor monitor) throws CoreException {
            ipsBuilder.clean(monitor);
        }

        public class EclipseBuilder implements ABuilder {

            @Override
            public AResourceDelta getDelta() {
                return wrap(EclipseIpsBuilder.this.getDelta(EclipseIpsBuilder.this.getProject()))
                        .as(AResourceDelta.class);
            }

            @Override
            public AProject getProject() {
                return wrap(EclipseIpsBuilder.this.getProject()).as(AProject.class);
            }

        }

    }

}
