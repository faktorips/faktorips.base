/*******************************************************************************
 * Copyright (c) Faktor Zehn GmbH - faktorzehn.org
 * 
 * This source code is available under the terms of the AGPL Affero General Public License version
 * 3.
 * 
 * Please see LICENSE.txt for full license terms, including the additional permissions and
 * restrictions as well as the possibility of alternative license terms.
 *******************************************************************************/

package org.faktorips.devtools.stdbuilder.xmodel.table;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.faktorips.datatype.Datatype;
import org.faktorips.devtools.model.ipsproject.IIpsProject;
import org.faktorips.devtools.model.tablestructure.IColumn;
import org.faktorips.devtools.model.tablestructure.IColumnRange;
import org.faktorips.devtools.model.tablestructure.IIndex;
import org.faktorips.devtools.model.tablestructure.ITableStructure;
import org.faktorips.devtools.stdbuilder.xmodel.ModelService;
import org.faktorips.devtools.stdbuilder.xtend.GeneratorModelContext;
import org.faktorips.runtime.ITable;
import org.faktorips.runtime.internal.Table;

/**
 * This is the generator model node representing a {@link ITableStructure}.
 * <p>
 * Note: At the moment only the table is not generated by the new Xpand builder. This class is only
 * used to get the correct interface and implementation name.
 * 
 * @author dirmeier
 */
public class XTable extends XTableStructure {

    private static final String METHOD_NAME_SUFFIX_FOR_NULL_VALUE_ROW = "NullRowReturnedForEmptyResult";
    private static final String METHOD_NAME_FIND = "find";
    private static final String METHOD_NAME_EXISTING = "Existing";
    private static final String METHOD_NAME_ROW = "Row";
    private static final String METHOD_NAME_FIND_ROW = METHOD_NAME_FIND + METHOD_NAME_ROW;

    public XTable(ITableStructure table, GeneratorModelContext context, ModelService modelService) {
        super(table, context, modelService);
    }

    @Override
    protected String getBaseSuperclassName() {
        return addImport(Table.class);
    }

    @Override
    public LinkedHashSet<String> getImplementedInterfaces() {
        LinkedHashSet<String> interfaces = new LinkedHashSet<>();
        interfaces.add(addImport(ITable.class));
        return interfaces;
    }

    private ITableStructure getTableStructure() {
        return (ITableStructure)getIpsObjectPartContainer().getIpsObject();
    }

    public boolean isSingleContentTable() {
        return !getTableStructure().isMultipleContentsAllowed();
    }

    private List<IIndex> getIndices() {
        return getTableStructure().getIndices();
    }

    public boolean hasIndices() {
        return !getIndices().isEmpty();
    }

    /**
     * 
     * @return all indices of table as a list of {@link XIndex}
     */
    public List<XIndex> getIndexModelNodes() {
        List<XIndex> result = new ArrayList<>();
        List<IIndex> indices = getIndices();
        for (int i = 0; i < indices.size(); i++) {
            XIndex indexNode = getModelNode(indices.get(i), XIndex.class);
            indexNode.setIndexInList(i);
            indexNode.setTableRowName(getTableRowName());
            result.add(indexNode);
        }
        return result;

    }

    /**
     * 
     * @return names of all valid columns as joined String list with ","
     */
    public String getColumnNames() {
        List<String> columnNames = new ArrayList<>();
        List<XColumn> columns = getValidColumns();
        for (XColumn column : columns) {
            columnNames.add(StringUtils.uncapitalize(column.getName()));
        }
        return StringUtils.join(columnNames, ",");
    }

    /**
     * 
     * @return a list of indices those have only column key items
     */
    public List<XIndex> getColumnKeyIndexModelNodes() {
        List<XIndex> keyIndices = new ArrayList<>();
        for (XIndex index : getIndexModelNodes()) {
            if (index.hasColumnKeys()) {
                keyIndices.add(index);
            }
        }
        return keyIndices;

    }

    /**
     * 
     * @param xIndex that is needed to check for suffix name
     * @return suffix name of given index if this index has the save structure to any other indices
     *             in the table, else there is no suffix name for this index
     */
    public String buildMethodNameSuffix(XIndex xIndex) {
        Set<IIndex> keysWithSameDatatypeSequence = getIndicesForKeysWithSameDatatypeSequence();
        if (keysWithSameDatatypeSequence.contains(xIndex.getIndex())) {
            StringBuilder keyName = new StringBuilder();
            String[] keyItems = xIndex.getIndex().getKeyItemNames();
            keyName.append("By");
            for (String keyItem : keyItems) {
                if (getTableStructure().hasColumn(keyItem)) {
                    keyName.append(StringUtils.capitalize(keyItem));
                } else {
                    IColumnRange range = getTableStructure().getRange(keyItem);
                    keyName.append(StringUtils.capitalize(range.getParameterName()));
                }
            }
            return keyName.toString();
        } else {
            return "";
        }

    }

    /**
     * 
     * @return a set of indices those have the same structure (same length and same structure of
     *             their key items)
     */
    private Set<IIndex> getIndicesForKeysWithSameDatatypeSequence() {
        List<IIndex> keys = getIndices();
        Set<IIndex> sameDatatype = new HashSet<>();
        int i = 0;
        for (IIndex key : keys) {
            for (int j = i + 1; j < keys.size(); j++) {
                IIndex key2 = keys.get(j);
                if (compareByDatatypeOnly(key, key2)) {
                    sameDatatype.add(key);
                    sameDatatype.add(key2);
                }
            }
            i++;
        }
        return sameDatatype;
    }

    /**
     * Compares two given indices by data type
     * 
     * @param first index
     * @param second index
     * @return true if two given indices have the same structure (same length and same structure of
     *             key items) else false
     */
    private boolean compareByDatatypeOnly(IIndex first, IIndex second) {

        String[] firstkeyItems = first.getKeyItemNames();
        String[] secondkeyItems = second.getKeyItemNames();

        if (firstkeyItems.length != secondkeyItems.length) {
            return false;
        }

        for (int i = 0; i < firstkeyItems.length; i++) {
            Datatype firstDatatype = getDatatypeForKeyName(firstkeyItems[i]);
            Datatype secondDatatype = getDatatypeForKeyName(secondkeyItems[i]);
            if (firstDatatype == null || secondDatatype == null || !firstDatatype.equals(secondDatatype)) {
                return false;
            }
        }
        return true;
    }

    /**
     * 
     * @param keyName of key item
     * @return data type of given key name
     */
    private Datatype getDatatypeForKeyName(String keyName) {
        IColumn column = getTableStructure().getColumn(keyName);
        if (column != null) {
            return findDatatype(column.getDatatype(), column.getIpsProject());
        }
        IColumnRange range = getTableStructure().getRange(keyName);
        if (range != null) {
            return findDatatype(range.getDatatype(), range.getIpsProject());
        }
        throw new RuntimeException("Unable to find column or columnRange for keyItemName: " + keyName);
    }

    static Datatype findDatatype(String name, IIpsProject ipsProject) {
        return ipsProject.findDatatype(name);
    }

    /**
     * 
     * @param index that is needed for name's building of findRow method
     * @return name of findRow method for given index
     */
    public String getMethodNameFindRow(XIndex index) {
        return METHOD_NAME_FIND_ROW + (index.isUniqueKey() ? "" : "s") + buildMethodNameSuffix(index);
    }

    /**
     * 
     * @param index that is needed for name's building of findRowNullRowReturned method
     * @return name of findRowNullRowReturned method for given index
     */
    public String getMethodNameFindRowNullRowReturned(XIndex index) {
        return METHOD_NAME_FIND_ROW + buildMethodNameSuffix(index) + METHOD_NAME_SUFFIX_FOR_NULL_VALUE_ROW;
    }

    /**
     * 
     * @param index that is needed for name's building of findExistingRow method
     * @return name of findExistingRow method for given index
     */
    public String getMethodNameFindExistingRow(XIndex index) {
        return METHOD_NAME_FIND + METHOD_NAME_EXISTING + METHOD_NAME_ROW + buildMethodNameSuffix(index);
    }

    /**
     * @return {@code "TableRow"} if the index is unique, otherwise {@code "Set<TableRow>"}.
     */
    public String getMethodReturnTypeFindRow(XIndex index) {
        if (index.isUniqueKey()) {
            return getTableRowName();
        } else {
            return addImport(Set.class) + "<" + getTableRowName() + ">";
        }
    }

    public String getTableRowName() {
        return getName() + "Row";
    }

}
