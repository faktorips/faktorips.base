Association_msg_MaxCardinalityMustBeAtLeast1=Die maximale Kardinali\u00E4t muss mindestens 1 sein.
Association_msg_MaxCardinalityForDerivedUnionTooLow=Die maximale Kardinalit\u00E4t muss gr\u00F6\u00DFer als 1 sein.
Association_msg_MinCardinalityGreaterThanMaxCardinality=Die minimale Kardinalit\u00E4t darf nicht gr\u00F6\u00DFer sein als die maximale.
Association_msgSubsetOfDerivedUnionSameMaxCardinality=Die obere Grenze der Kardinalit\u00E4t muss gleich der oberen Grenze der Kardinalit\u00E4t der abgeleiteten Vereinigungsbeziehung des Supertypen sein.
Association_msg_TargetRolePlural=Rollenname (plural)
Association_msg_TargetRoleSingular=Rollenname (singular)
Association_msg_TargetRoleSingularNotAValidJavaFieldName=Der Rollenname (singular) ''{0}'' ist kein gültiger Java-Name.
Association_msg_TargetRolePluralNotAValidJavaFieldName=Der Rollenname (plural) ''{0}'' ist kein gültiger Java-Name.
Association_msgDerivedUnionNotSubset=Die abgeleitete Vereinigung darf nicht ihre eigene Teilmenge sein.
Association_msg_DerivedUnionDoesNotExist=Die abgeleitete Beziehung {0} existiert nicht in der Hierarchie.
Association_msg_NotMarkedAsDerivedUnion=Die angegebene Beziehung ist nicht als abgeleitete Vereinigung markiert.
Association_msg_TargetOfDerivedUnionDoesNotExist=Der Rollenname der abgeleiteten Vereinigungsbeziehung ist entweder leer oder das Ziel existiert nicht.
Association_msg_TargetNotSubclass=Der Zieltyp der Beziehung ist kein Subtyp (oder der gleiche Typ) des Zieltyps der abgeleiteten Vereinigungsbeziehung.
Association_msg_ConstrainedAssociationSingularDoesNotExist=Es wurde keine überschreibbare Beziehung mit dem Namen \"{0}\" gefunden.
Association_msg_ConstrainedAssociationPluralDoesNotExist=Der plural Rollenname muss mit dem der überschriebenen Beziehung übereinstimmen. Erwartet wird \"{0}\".
Association_msg_ConstraintIsSubsetOfDerivedUnion=Eine Teilmenge einer abgleiteten Vereinigung kann keine andere Beziehung überschreiben.
Association_msg_ConstraintIsDerivedUnion=Eine abgleitete Vereinigung kann keine andere Beziehung überschreiben.
Association_msg_ConstrainedIsSubsetOfDerivedUnion=Eine Teilmenge einer abgleiteten Vereinigung kann nicht überschrieben werden.
Association_msg_ConstrainedIsDerivedUnion=Eine abgleitete Vereinigung kann nicht überschrieben werden.
Association_msg_ConstrainedTargetNoSuperclass=Das Ziel dieser Beziehung muss eine Subklasse des Ziels der überschriebenen Beziehung sein.
Association_msg_MaxCardinalityForConstrainMustAllowMultipleItems=Die maximale Kardinalität muss größer als 1 sein, da die überschriebene Beziehung aus mehreren Elementen bestehen kann.
Association_msg_MaxCardinalityForConstrainLowerThanSuperAssociation=Die maximale Kardinalität muss gleich oder höher als die maximale Kardinalität der überschriebenen Beziehung ({0}) sein.
Association_msg_MinCardinalityForConstrainHigherThanSuperAssociation=Die minimale Kardinalität muss gleich oder niedriger als die minimale Kardinalität der überschriebenen Beziehung ({0}) sein.
Association_msg_AssociationTypeNotEqualToSuperAssociation=Der Beziehungstyp muss wie in der überschriebenen Beziehung sein: {0}
Association_msg_ConstrainedInvalidMatchingAssociation=\u00DCberschriebene Beziehungen m\u00FCssen sich auf Vertrags- und Produktseite entsprechen.

Attribute_msg_InvalidAttributeName=Ung\u00FCltiger Attributname{0}\!
Attribute_msg_DefaultNotParsable_UnknownDatatype=Der Vorbelegungswert {0} kann nicht geparsed werden , da der Datentyp unbekannt ist.
Attribute_msg_DefaultValueIsEmptyString="leere Zeichenkette"
Attribute_msg_ValueTypeMismatch=Der Vorbelegungswert {0} ist kein {1}.
Attribute_msg_DefaultNotInValueset=Der Vorbelegungswert {0} ist nicht in der angegebenen Wertemenge enthalten.
Attribute_msgNothingToOverwrite=Das Attribut {0} existiert in der Supertyp-Hierarchie nicht, daher kann nichts \u00FCberschrieben werden.
Attribute_msg_Overwritten_modifier_different=Die Sichtbarkeit ist unterschiedlich zur Sichtbarkeit des \u00FCberschriebenen Attributes\!
Attribute_msg_Overwritten_type_incompatible=Der Datentyp des Attributes {0} muss der gleiche oder ein Subtyp des Datentyps vom überschriebenen Attribut sein.
Attribute_ValueSet_not_SubValueSet_of_the_overridden_attribute=Die Wertemenge des Attributs \"{0}\" muss eine Teilmenge der Wertemenge des \u00FCberschriebenen Attributs \"{1}\" sein.
Attribute_msgOverwritten_ChangingOverTimeAttribute_different=Der Wert für Änderungen im Zeitablauf ist unterschiedlich zum überschriebenen Attribut.

TypeMethod_duplicateSignature=Der Typ enth\u00E4lt bereits eine Methode mit der gleichen Signatur.
TypeMethod_incompatbileReturnType=Der Ergebnistyp ist inkompatibel mit {0}.{1}
TypeMethod_msg_abstractMethodError=Die abstrakte Methode {0} muss zu einem abstrakten Typen geh\u00F6ren.
TypeMethod_msg_modifierOverriddenNotEqual=Diese Methode muss die gleiche Sichtbarkeit haben wie die überschriebene Methode. ({0})

Type_msg_AbstractMissmatch=Nur eine abstrakter Typ kann abstrakte Methoden haben.
Type_msg_supertypeNotFound=Der Supertyp {0} kann nicht gefunden werden.
Type_msg_cycleInTypeHierarchy=Die Supertyp-Beziehung des Typen ist zyklisch!
Type_msg_MustOverrideAbstractMethod=Die in {1} definierte abstrakte Methode {0} muss implementiert werden.
Type_msg_MustImplementDerivedUnion=Der Typ muss entweder die in {1} definierte abgeleitete Vereinigungsbeziehung {0} implementieren oder als abstrakt markiert werden.\n(Diese Regel kann in der .ipsproject Datei via ''derivedUnionIsImplementedRuleEnabled'' ausgeschaltet werden.)
Type_msg_MustImplementInverseDerivedUnion=Der Typ muss entweder die inverse der in {1} definierte abgeleitete Vereinigungsbeziehung {0} implementieren oder als abstrakt markiert werden.\n(Diese Regel kann in der .ipsproject Datei via ''derivedUnionIsImplementedRuleEnabled'' ausgeschaltet werden.)
Type_msg_TypeHierarchyInconsistent=Die Supertyp-Hierarchie des Typs ist inkonsistent.

DuplicatePropertyNameValidator_msg=Der Name {0} ist nicht eindeutig. {1} (Gro\u00DF- und Kleinschreibung wird bei einem Vergleich ignoriert).
DuplicatePropertyNameValidator_msg_DifferentElementsSameType={0} und {1} dürfen nicht gleich heißen. 
DuplicatePropertyNameValidator_msg_DifferentElementsAndITypes=Es gibt mindestens {0} im Typ {1} mit dem gleichen Namen.  
DuplicatePropertyNameValidator_PluralAttribute=Attribute
DuplicatePropertyNameValidator_SingularAttribute=ein Attribut
DuplicatePropertyNameValidator_PluralAssociation=Beziehungen
DuplicatePropertyNameValidator_SingularAssociation=eine Beziehung
DuplicatePropertyNameValidator_PluralMethod=Methoden
DuplicatePropertyNameValidator_SingularMethod=eine Methode
DuplicatePropertyNameValidator_PluralElement=andere Elemente
DuplicatePropertyNameValidator_SingularElement=ein Element
DuplicatePropertyNameValidator_ProductCmptTypeItself=der Produktbausteintyp selbst

AttributeAbstractDatatypeValidator_msg=Das Attribut {0} hat einen abstrakten Datentyp, die Klasse ist aber nicht abstrakt.
AttributeAbstractDatatypeValidator_hint=\ Sie können das Attribut überschreiben und einen konkreten Datentyp zuweisen.

Type_msgOtherTypeWithSameQNameInSameProject=Es existiert bereits eine {0} mit dem gleichen qualifizierten Namen im gleichen Projekt.
Type_msgOtherTypeWithSameQNameInDependentProject=Es existiert bereits eine {0} mit dem gleichen qualifizierten Namen im IPS-Projekt: {1}. Im IPS-Objektpfad dieses IPS-Projektes ist der Eintrag f?r das IPS-Projekt {1} vor dem Quellordnereintrag. Der IPS-Objektpfad sollte angepasst werden.
