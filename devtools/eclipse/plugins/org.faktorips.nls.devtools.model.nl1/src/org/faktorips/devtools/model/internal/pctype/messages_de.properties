PersistentAssociationInfo_joinColumnName=Join-Spaltenname
PersistentAssociationInfo_joinTableName=Join-Tabellenname
PersistentAssociationInfo_msgIsInvalid={0} ist ung\u00FCltig.
PersistentAssociationInfo_msgJoinTableNameExceedsMaximumLength=Der Join-Tabellenname ist l\u00e4nger als die maximal erlaubte L\u00e4nge definiert in den Persistenz-Optionen. Die aktuelle L\u00e4nge ist {0} und die maximal erlaubte L\u00e4nge ist {1}.
PersistentAssociationInfo_msgLazyFetchNotSupported=Lazy Fetching wird nicht bei "toOne"-Assoziationen unterst\u00fctzt.
PersistentAssociationInfo_msgMaxLengthExceeds=Die L\u00e4nge vom {0} ist l\u00e4nger als die maximal erlaubte L\u00e4nge definiert in den Persistenz-Optionen. Die aktuelle L\u00e4nge ist {0} und die maximal erlaubte L\u00e4nge ist {1}.
PersistentAssociationInfo_msgMustBeEmpty={0} darf nicht gef\u00FCllt sein
PersistentAssociationInfo_msgMustNotBeEmpty={0} muss gef\u00FCllt sein
PersistentAssociationInfo_msgOwningSideManyToManyMarkedOnBothSides=Beide Seiten der Beziehung sind als Eigent\u00fcmer markiert.
PersistentAssociationInfo_msgOwningSideManyToManyNotAllowed=Darf nicht als Eigent\u00fcmer der Beziehung markiert werden, da eine Join-Tabelle nicht ben\u00f6tigt ist.
PersistentAssociationInfo_msgOwningSideMissing=Eine Seite der Beziehung muss als Eigent\u00fcmer markiert werden.
PersistentAssociationInfo_msgTransientMismatch=Wenn die Target-Seite der Assoziation oder die Target-Entity als transient gekennzeichnet ist, muss diese Seite ebenfalls als transient gekennzeichnet werden und umgekehrt.
PersistentAssociationInfo_msgChildToParentCascadeType=Eine Kind-zu-Elternteil-Beziehung kann keinen Cascade-Type aktiviert haben.
PersistentAssociationInfo_sourceColumnName=Source-Spaltenname
PersistentAssociationInfo_tagetColumnName=Target-Spaltenname

PersistentAttributeInfo_msgColumnNameLengthExceedsMaximumLength=Die L\u00e4nge des Spaltennamens ist l\u00e4nger als die maximal erlaubte L\u00e4nge definiert in den Persistenz-Optionen. Die aktuelle L\u00e4nge ist {0} und die maximal erlaubte L\u00e4nge ist {1}.
PersistentAttributeInfo_msgColumnNameMustBeEmpty=Der Spaltenname muss leer sein, da das Attribut abgeleitet ist.
PersistentAttributeInfo_msgColumnNameMustNotContainWhitespaceCharacters= Der Spaltenname darf keine Leerzeichen enthalten.
PersistentAttributeInfo_msgColumnPrecisionExceedsTheLimit=Spalten-Precision erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnScaleExceedsTheLimit=Spalten-Scale erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnSizeExceedsTheLimit=Spalten-Size erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgEmptyColumnName=Der Spaltenname ist leer.
PersistentAttributeInfo_msgColumnSizeNotRestrictedInModel=Der Wertebereich sollte im Modell eingeschr\u00E4nkt werden, um den Persistenzeinstellungen zu entsprechen (Spalten-Size max. {0})
PersistentAttributeInfo_msgModelExceedsColumnSize=Die maximale Stringl\u00E4nge im Modell ({0}) \u00FCbersteigt das f\u00fcr die Persistenz eingestellt Limit ({1})
PersistentAttributeInfo_msgColumnNullableDoesNotMatchModel=Das Modell erlaubt null-Werte, obwohl diese in den Persistenzeinstellungen nicht erlaubt sind
PersistentInfo_msgIndexNameIsInvalid={0} ist kein g\u00FCltiger Name f\u00FCr einen Index.

PersistentTypeInfo_msgDiscriminatorAlreadyDefined=Der Diskriminator-Wert "{0}" wird schon im Supertyp {1} verwendet.
PersistentTypeInfo_msgDiscriminatorColumnNameIsInvalid=Der Name der Diskriminator-Spalte ist ung\u00FCltig.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedBecauseMappedSuperclass=Die Diskriminator-Definition ist hier nicht erlaubt, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedNotRootEntity=Die Diskriminator-Definition ist hier nicht erlaubt, da dies nicht die Root-Entity ist.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedTypeNotDefDiscrColumn=Die Diskriminator-Definition ist hier nicht erlaubt, da hier keine Diskriminator-Spalte definiert ist.
PersistentTypeInfo_msgDiscriminatorMustBeDefinedInTheRootEntity=Der Diskriminator muss in der Root-Entity {0} definiert werden.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmpty=Es darf kein Diskriminator-Wert angegeben werden, wenn in der Root-Entity keine Diskriminator-Spalte angegeben wurde oder der Typ abstrakt ist.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmptyBecauseMappedSuperclass=Es darf kein Diskriminator-Wert angegeben werden, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgDiscriminatorValueMustNotBeEmpty=Es muss ein Diskriminator-Wert angegeben werden, wenn in der Root-Entity die Diskriminator-Spalte angegeben wurde und der Typ nicht abstrakt ist.
PersistentTypeInfo_msgDiscriminatorValueNotConform=Der Diskriminator-Wert passt nicht nicht zum angegebenen Datentyp.
PersistentTypeInfo_msgDiscriminatorValueTooLong=Der Diskriminator-Wert \u00FCberschreitet die maximale L\u00E4nge von {0} die in der Root-Entity definiert wurde.
PersistentTypeInfo_msgDuplicateColumnName=Doppelter Spaltenname {0}
PersistentTypeInfo_msgFoundDuplicateColumnNameIn=. Doppelter Name in {0}.
PersistentTypeInfo_msgInvalidInheritanceStratedyCombination=Ung\u00FCltige Kombination der Ableitungsstrategie, die Ableitungsstrategie muss in {0} ({1}) oder {2} ({3}) angepasst werden.
PersistentTypeInfo_msgTableNameExceedsMaximumLength=Die L\u00e4nge des Tabellennamens ist l\u00e4nger als die maximal erlaubte L\u00e4nge definiert in den Persistenz-Optionen. Die aktuelle L\u00e4nge ist {0} und die maximal erlaubte L\u00e4nge ist {1}.
PersistentTypeInfo_msgTableNameInvalid=Der Tabellenname ist ung\u00FCltig
PersistentTypeInfo_msgTableNameMustBeEmptyBecauseNameDefinedInSupertypeShouldBeUsed=Es darf kein Tabellenname angegeben werden, da der im Supertyp definierte Tabellenname verwendet werden soll.
PersistentTypeInfo_msgTableNameMustBeEmptyMappedSuperclass=Es darf kein Tabellenname angegeben werden, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgTableNameMustBeEmptyNotRootEntityAndInhStrategyIs=Es darf kein Tabellenname angegeben werden, da dies die Root-Entity ist und die Ableitungsstrategie {0} ist
PersistentTypeInfo_msgTableNameOfRootEntityMustBeUsed=Es muss der Tabellenname der Root-Entity verwendet werden, da die Ableitungsstrategie {0} ist und dies nicht die Root-Entity ist.
PersistentTypeInfo_msgUseTableDefInSupertypIsNotAllowed=Kein Supertyp definiert, deswegen kann auch nicht der im Supertyp definierte Tabellenname verwendet werden.

PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmpty=F\u00FCr Detail-to-Master-Beziehungen muss eine inverse Beziehung angegeben werden.
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmptyIfDerivedUnionHasInverse=Es muss eine inverse Beziehung angegeben werden, wenn die abgeleitete Vereinigung eine inverse Beziehung besitzt.
PolicyCmptTypeAssociation_Association_msg_InverseOfMasterToDetailMustBeADetailToMaster=Die inverse Beziehung einer Master-to-Detail Beziehung muss eine Detail-to-Master Beziehung sein.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalid=Die entsprechende Beziehung referenziert diese Beziehung nicht.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForConfiguredType=F\u00fcr produktkonfigurierte Vertragsteilklassen muss die entsprechende Produktbausteinklasse verwendet werden.    
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForNotConfiguredType=Die angegebene Produktbausteinklasse muss eine Vertragsteilklasse der Struktur konfigurieren.
PolicyCmptTypeAssociation_error_matchingAssociatonNotFound=Die Assoziation {0} in der Produktbausteinklasse {1} kann nicht gefunden werden.
PolicyCmptTypeAssociation_errorMsg_constrainedPropertyQualifiedMismatch=Die Eigenschaft "qualifiziert" muss wie in der \u00fcberschriebenen Beziehung gesetzt sein.
PolicyCmptTypeAssociation_InverseOfDetailToMasterMustBeAMasterToDetail=Die inverse Beziehung einer Detail-to-Master Beziehung muss eine Master-to-Detail Beziehung sein.
PolicyCmptTypeAssociation_sharedAssociation_invalidAssociationHost=Die zu dieser gemeinsam genutzen Beziehung geh\u00f6rende Beziehung in der Superklasse muss die inverse Beziehung einer abgeleiteten Vereinigung sein. 
PolicyCmptTypeAssociation_sharedAssociation_noAssociationHost=Zu einer gemeinsam genutzten Beziehung muss eine Beziehung mit gleichem Namen und Ziel in der Superklasse existieren.

PolicyCmptTypeAttribute_msg_AbstractCantBeProductRelevant=Das Attribut {0} verwendet den abstrakten Datentyp {1} und darf deshalb nicht als produktkonfigurierbar markiert werden. Markieren Sie stattdessen die \u00dcberschreibung mit einem konkreten Datentyp als produktkonfigurierbar.
PolicyCmptTypeAttribute_msg_IllegalValueSetType=Der Wertemengentyp {0} ist nicht erlaubt.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureDoesNotExists=Die angegebende Methode existiert nicht.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureHasADifferentDatatype=Die angegebende Methode hat einen anderen Datentyp wie dieses Attribut.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureIsMissing=Es fehlt die Referenz auf die Methode, die das Attribut {0} berechnet.
PolicyCmptTypeAttribute_msg_ConstantCantBeAbstract=Ein konstantes Attribut darf keinen abstrakten Datentyp verwenden.
PolicyCmptTypeAttribute_msg_EmptyMandatoryValueSet=Der Wertebereich des Attributs {0} ist als Pflichtfeld und produktrelevant konfiguriert, erlaubt aber keine Werte. Eine g\u00FCltige Produktkonfiguration ist so unm\u00F6glich. Erlauben Sie <null> und machen das Attribut damit optional, oder erlauben Sie mindestens einen Wert. 
PolicyCmptTypeAttribute_TypeOfOverwrittenAttributeCantBeChanged=Der Typ eines \u00fcberschriebenen Attributes kann nur von "abgeleitet (Berechnung bei jedem Aufruf)" zu "\u00e4nderbar" ge\u00e4ndert werden.
PolicyCmptTypeAttribute_OverwrittenAttributeDisabledGenericValidation=Die generische Validierung muss aktiviert sein, weil sie im \u00FCberschriebenen Attribut aktiviert ist.

PolicyCmptType_productCmptType=Produktbausteintyp
PolicyCmptType_msg_ProductCmptTypeNameMissing=Der Name des Produktbausteintyps fehlt.
PolicyCmptType_msgDuplicateRuleName=Es existiert eine weitere Validierungsregel mit dem selben Namen in diesem Typ (oder der Supertyp-Hierarchie). Diese Regel ist nicht als \u00FCberschreibend markiert. Regelnamen m\u00FCssen eindeutig sein.
PolicyCmptType_msgInverseDerivedUnionNotSepcified=Es wurde keine inverse Beziehung f\u00FCr die derived union "{0}" im Typ "{1}" gefunden
PolicyCmptType_msgRuleMethodNameConflict=Namenskonflikt f\u00FCr Regel "{0}". Der Name wird auch von einer Methode dieses Typs (oder der Supertyp-Hierarchie) verwendet.
PolicyCmptType_msgSubtypeConfigurableWhenSupertypeConfigurable=Der Supertyp ist konfigurierbar, deshalb muss dieser Typ auch konfigurierbar sein.
PolicyCmptType_TheTypeDoesNotConfigureThisType=Der Typ {0} konfiguriert diesen Typ nicht.
PolicyCmptType_caption=Vertragsteiltyp
PolicyCmptType_msgDifferentGenerateValidatorClassSetting=Nicht alle Typen in der Hierarchie ({0}) haben die gleiche Einstellung f\u00fcr das Erzeugen einer separaten Validierungsklasse.

Association_msg_InverseAssociationInconsistentWithDerivedUnion=Die inverse Beziehung ist inkonsistent mit der abgeleiteten Vereinigung {0}.
Association_msg_AssociationNotFoundInTarget=Die Beziehung {0} existiert im Zieltyp {1} nicht.
Association_msg_InverseAssociationMismatch=Die inverse Beziehung nennt nicht diese Beziehung als ihre inverse Beziehung\!
Association_msg_InverseAssociationMustBeMarkedAsDerivedUnionToo=Die inverse Beziehung dieser Beziehung ist nicht als abgeleitete Vereinigung markiert.
Association_msg_InverseAssociationMustBeOfTypeAssociation=Die inverse Beziehung einer Assoziation muss eine Assoziation sein\!
Association_msg_DetailToMasterAssociationMustHaveMaxCardinality1=Eine Detail-to-Master-Beziehung muss die maximale Kardinalit\u00E4t 1 haben.

ValidationRule_msg_InvalidMarkerId=Die Marker Ids {0} existieren nicht in "{1}".
ValidationRule_msgUndefinedAttribute=Das angegebene Attribut ist in dem Vertragsteiltyp dieser Regel nicht definiert.
ValidationRule_msgCodeShouldBeProvided=Die Regel sollte einen Message Code enthaltenen, das erleichert z. B. das Testen der Regel.
ValidationRule_ConstantAttributesCantBeValidated=Konstante Attribute k\u00F6nnen nicht validiert werden\! 
ValidationRule_msgDuplicateEntries=Doppelte Eintr\u00E4ge.
ValidationRule_msgNoNewlineAllowed=Im Meldungstext ist kein Zeilenumbruch erlaubt. (Text auf {0})
ValidationRule_msgValueSetRule=F\u00FCr ein Attribut mit unbegrenztem Wertebereich kann keine Regel zur Pr\u00FCfung, ob ein Wert in diesem Bereich enthalten ist, generiert werden.
ValidationRuleMessageText_warning_invalidParameter=Der Parameter {0} in der Sprache {1} wird nicht in der Standardsprache verwendet.
ValidationRule_msgMissingAttribute=Dies ist eine spezielle Regel, um das Attribut {0} gegen seinen Wertebereich zu pr\u00FCfen. Das Attribut existiert nicht.
ValidationRule_msgNothingToOverwrite=Die Regel {0} existiert in der Supertyp-Hierarchie nicht, daher kann nichts \u00FCberschrieben werden.
ValidationRule_msgOverwritten_ChangingOverTimeAttribute_different=Der Wert f\u00fcr \u00C4nderungen im Zeitablauf ist unterschiedlich zur \u00FCberschriebenen Regel.

Attribute_msgAttributeCantBeProductRelevantIfTypeIsNot=Ein Attribut kann nicht konfiguriert werden, wenn der Typ nicht konfigurierbar ist.
Attribute_proposalForMsgCode={0}_UNGUELTIG
Attribute_proposalForRuleName=pruefe{0}
Attribute_proposalForRuleNameDuplicated=pruefe{0}Wertebereich

Attribute_msg_Overwritten_datatype_different=Der Datentyp ist unterschiedlich zum Datentyp des \u00FCberschriebenen Attributes\!
MarkerEnumUtil_invalidMarkerEnum=<ung\u00fcltiges Marker Enum>
