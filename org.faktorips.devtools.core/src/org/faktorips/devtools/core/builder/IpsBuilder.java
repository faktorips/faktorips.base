/*******************************************************************************
 * Copyright (c) 2005-2010 Faktor Zehn AG und andere.
 * 
 * Alle Rechte vorbehalten.
 * 
 * Dieses Programm und alle mitgelieferten Sachen (Dokumentationen, Beispiele, Konfigurationen,
 * etc.) duerfen nur unter den Bedingungen der Faktor-Zehn-Community Lizenzvereinbarung - Version
 * 0.1 (vor Gruendung Community) genutzt werden, die Bestandteil der Auslieferung ist und auch unter
 * http://www.faktorzehn.org/fips:lizenz eingesehen werden kann.
 * 
 * Mitwirkende: Faktor Zehn AG - initial API and implementation - http://www.faktorzehn.de
 *******************************************************************************/

package org.faktorips.devtools.core.builder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.MultiStatus;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.osgi.util.NLS;
import org.faktorips.devtools.core.IpsPlugin;
import org.faktorips.devtools.core.IpsStatus;
import org.faktorips.devtools.core.internal.model.IpsModel;
import org.faktorips.devtools.core.internal.model.ipsobject.IpsSrcFile;
import org.faktorips.devtools.core.model.DependencyType;
import org.faktorips.devtools.core.model.IDependency;
import org.faktorips.devtools.core.model.IIpsElement;
import org.faktorips.devtools.core.model.ipsobject.IIpsObject;
import org.faktorips.devtools.core.model.ipsobject.IIpsSrcFile;
import org.faktorips.devtools.core.model.ipsobject.QualifiedNameType;
import org.faktorips.devtools.core.model.ipsproject.IIpsArchiveEntry;
import org.faktorips.devtools.core.model.ipsproject.IIpsArtefactBuilder;
import org.faktorips.devtools.core.model.ipsproject.IIpsArtefactBuilderSet;
import org.faktorips.devtools.core.model.ipsproject.IIpsPackageFragment;
import org.faktorips.devtools.core.model.ipsproject.IIpsPackageFragmentRoot;
import org.faktorips.devtools.core.model.ipsproject.IIpsProject;
import org.faktorips.util.message.Message;
import org.faktorips.util.message.MessageList;

/**
 * The IPS builder generates Java sourcecode and XML files based on the IPS objects contained in the
 * IPS project. It runs before the Java builder, so that first the Java sourcecode is generated by
 * the IPS builder and then the Java builder compiles the Java sourcecode into class files.
 */
public class IpsBuilder extends IncrementalProjectBuilder {

    /**
     * The builders extension id.
     */
    public final static String BUILDER_ID = IpsPlugin.PLUGIN_ID + ".ipsbuilder"; //$NON-NLS-1$

    public final static boolean TRACE_BUILDER_TRACE;

    static {
        TRACE_BUILDER_TRACE = Boolean
                .valueOf(Platform.getDebugOption("org.faktorips.devtools.core/trace/builder")).booleanValue(); //$NON-NLS-1$
    }

    /**
     * The key is the name of the IpsProject, the value the last modification time stamp of the
     * IpsProjectProperties from the last build.
     */
    private Map<String, Long> lastModificationTimestampForBuilderSets = new HashMap<String, Long>();

    public IpsBuilder() {
        super();
    }

    private MultiStatus createInitialMultiStatus() {
        return new MultiStatus(IpsPlugin.PLUGIN_ID, 0, Messages.IpsBuilder_msgBuildResults, null);
    }

    @SuppressWarnings("unchecked")
    @Override
    protected IProject[] build(int kind, Map args, IProgressMonitor monitor) throws CoreException {
        MultiStatus buildStatus = createInitialMultiStatus();
        try {
            monitor.beginTask("build", 100000); //$NON-NLS-1$
            monitor.subTask(Messages.IpsBuilder_validatingProject);
            /*
             * We have to clear the validation cache as for example the deletion of IPS source files
             * migth still be undetected as the validation result cache gets cleared in a resource
             * change listener. it is not guaranteed that the listener is notified before the build
             * starts!
             */
            getIpsProject().getIpsModel().clearValidationCache();
            if (!checkIpsProjectBeforeBuild(getProject(), getIpsProject())) {
                monitor.done();
                return null;
            }
            monitor.worked(100);
            monitor.subTask(Messages.IpsBuilder_preparingBuild);
            IIpsArtefactBuilderSet ipsArtefactBuilderSet = getBuilderSetReInitialisedIfNecessary(getIpsProject());
            boolean isFullBuildRequired = isFullBuildRequired(kind);
            if (isFullBuildRequired) {
                kind = IncrementalProjectBuilder.FULL_BUILD;
            }
            beforeBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, kind);
            applyBuildCommand(ipsArtefactBuilderSet, buildStatus, new BeforeBuildProcessCommand(kind, getIpsProject()),
                    monitor);
            monitor.worked(100);
            try {
                if (isFullBuildRequired) {
                    kind = IncrementalProjectBuilder.FULL_BUILD;
                    monitor.subTask(Messages.IpsBuilder_startFullBuild);
                    fullBuild(ipsArtefactBuilderSet, buildStatus, new SubProgressMonitor(monitor, 99700));
                } else {
                    monitor.subTask(Messages.IpsBuilder_startIncrementalBuild);
                    incrementalBuild(ipsArtefactBuilderSet, buildStatus, new SubProgressMonitor(monitor, 99700));
                }
            } finally {
                monitor.subTask(Messages.IpsBuilder_finishBuild);
                applyBuildCommand(ipsArtefactBuilderSet, buildStatus, new AfterBuildProcessCommand(kind,
                        getIpsProject()), monitor);
                afterBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, kind);
            }
            monitor.worked(100);
            if (buildStatus.getSeverity() == IStatus.OK) {
                return getProject().getReferencedProjects();
            }

            // Re-initialize the builders of the current builder set if an error occurs.
            getIpsProject().reinitializeIpsArtefactBuilderSet();
            throw new CoreException(buildStatus);

        } catch (OperationCanceledException e) {
            getIpsProject().reinitializeIpsArtefactBuilderSet();
        } catch (CoreException e) {
            throw e;
        } catch (Throwable t) {
            /*
             * Need to catch Throwable. If the incremental project builder throws an error, Eclipse
             * just writes a Warning to the error log. So we wrap the error into a CoreException.
             */
            throw new CoreException(new IpsStatus(t));
        } finally {
            monitor.done();
        }
        return getProject().getReferencedProjects();
    }

    private IIpsArtefactBuilderSet getBuilderSetReInitialisedIfNecessary(IIpsProject project) throws CoreException {
        Long timestamp = lastModificationTimestampForBuilderSets.get(project.getName());
        if (timestamp == null) {
            lastModificationTimestampForBuilderSets.put(project.getName(), project.getReadOnlyProperties()
                    .getLastPersistentModificationTimestamp());
            return project.getIpsArtefactBuilderSet();
        }

        Long projectTimestamp = project.getReadOnlyProperties().getLastPersistentModificationTimestamp();
        if (!timestamp.equals(projectTimestamp)) {
            project.reinitializeIpsArtefactBuilderSet();
            lastModificationTimestampForBuilderSets.put(project.getName(), projectTimestamp);
        }
        return project.getIpsArtefactBuilderSet();
    }

    private boolean checkIpsProjectBeforeBuild(IProject project, IIpsProject ipsProject) throws CoreException {
        project.deleteMarkers(IpsPlugin.PROBLEM_MARKER, true, 0);
        MessageList list = ipsProject.validate();
        IResource markedResource = ipsProject.getIpsProjectPropertiesFile();
        if (!markedResource.exists()) {
            markedResource = project;
        }
        createMarkersFromMessageList(markedResource, list, IpsPlugin.PROBLEM_MARKER);
        if (!getIpsProject().canBeBuild()) {
            IMarker marker = markedResource.createMarker(IpsPlugin.PROBLEM_MARKER);
            String msg = Messages.IpsBuilder_msgInvalidProperties;
            updateMarker(marker, msg, IMarker.SEVERITY_ERROR);
            return false;
        }
        return true;
    }

    private boolean isFullBuildRequired(int kind) throws CoreException {
        if (kind == FULL_BUILD || kind == CLEAN_BUILD) {
            return true;
        }
        IResourceDelta delta = getDelta(getProject());
        if (delta == null) {
            return true;
        }
        IIpsProject ipsProject = getIpsProject();
        if (delta.findMember(ipsProject.getIpsProjectPropertiesFile().getProjectRelativePath()) != null) {
            return true;
        }
        IIpsArchiveEntry[] entries = ipsProject.getIpsObjectPath().getArchiveEntries();
        for (IIpsArchiveEntry entrie : entries) {
            if (entrie.isContained(delta)) {
                return true;
            }
        }
        return false;
    }

    private void beforeBuildForBuilderSet(IIpsArtefactBuilderSet builderSet, MultiStatus buildStatus, int buildKind) {
        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!IpsPlugin.getDefault().getIpsPreferences().getEnableGenerating()) {
            return;
        }
        try {
            builderSet.beforeBuildProcess(buildKind);
        } catch (Exception e) {
            buildStatus.add(new IpsStatus(
                    "Error during beforeBuildProcess() of the builder set: " + builderSet.getId(), e)); //$NON-NLS-1$
        }
    }

    private void afterBuildForBuilderSet(IIpsArtefactBuilderSet builderSet, MultiStatus buildStatus, int buildKind) {
        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!IpsPlugin.getDefault().getIpsPreferences().getEnableGenerating()) {
            return;
        }
        try {
            builderSet.afterBuildProcess(buildKind);
        } catch (Exception e) {
            buildStatus.add(new IpsStatus("Error during afterBuildProcess() of the builder set: " + builderSet.getId(), //$NON-NLS-1$
                    e));
        }
    }

    private void applyBuildCommand(IIpsArtefactBuilderSet currentBuilderSet,
            MultiStatus buildStatus,
            BuildCommand command,
            IProgressMonitor monitor) {

        /*
         * Despite the fact that generating is disabled in the Faktor-IPS preferences the validation
         * of the model class instances and marker updating of the regarding resource files still
         * takes place.
         */
        if (!IpsPlugin.getDefault().getIpsPreferences().getEnableGenerating()) {
            return;
        }
        IIpsArtefactBuilder[] artefactBuilders = currentBuilderSet.getArtefactBuilders();
        for (IIpsArtefactBuilder artefactBuilder : artefactBuilders) {
            try {
                command.build(artefactBuilder, buildStatus);
            } catch (Exception e) {
                addIpsStatus(artefactBuilder, command, buildStatus, e);
            }
        }
        if (monitor.isCanceled()) {
            throw new OperationCanceledException();
        }
    }

    private void addIpsStatus(IIpsArtefactBuilder builder, BuildCommand command, MultiStatus buildStatus, Exception e) {
        String text = builder.getName() + ": Error during: " + command + "."; //$NON-NLS-1$ //$NON-NLS-2$
        buildStatus.add(new IpsStatus(text, e));
    }

    private DependencyGraph getDependencyGraph() throws CoreException {
        IpsModel model = ((IpsModel)getIpsProject().getIpsModel());
        return model.getDependencyGraph(getIpsProject());
    }

    /**
     * Returns the IPS project the build is currently building.
     */
    private IIpsProject getIpsProject() {
        return IpsPlugin.getDefault().getIpsModel().getIpsProject(getProject());
    }

    private void collectIpsSrcFilesForFullBuild(List<IIpsSrcFile> allIpsSrcFiles) throws CoreException {
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (int i = 0; i < roots.length; i++) {
            if (!roots[i].isBasedOnSourceFolder()) {
                continue;
            }
            IIpsPackageFragment[] packs = roots[i].getIpsPackageFragments();
            for (IIpsPackageFragment pack : packs) {
                IIpsElement[] elements = pack.getChildren();
                for (IIpsElement element : elements) {
                    if (element instanceof IIpsSrcFile) {
                        allIpsSrcFiles.add((IIpsSrcFile)element);
                    }
                }
            }
        }
    }

    private void removeEmptyFolders() throws CoreException {
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (IIpsPackageFragmentRoot root : roots) {
            if (root.isBasedOnSourceFolder()) {
                removeEmptyFolders(root.getArtefactDestination(false), false);
            }
        }
    }

    /**
     * Full build generates Java source files for all IPS objects.
     */
    private MultiStatus fullBuild(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor) {
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Full build started."); //$NON-NLS-1$
        }
        long begin = System.currentTimeMillis();

        try {
            List<IIpsSrcFile> allIpsSrcFiles = new ArrayList<IIpsSrcFile>();
            collectIpsSrcFilesForFullBuild(allIpsSrcFiles);
            monitor.beginTask("full build", 2 * allIpsSrcFiles.size()); //$NON-NLS-1$
            getDependencyGraph().reInit();
            monitor.worked(allIpsSrcFiles.size());
            removeEmptyFolders();

            for (IIpsSrcFile ipsSrcFile : allIpsSrcFiles) {
                if (monitor.isCanceled()) {
                    break;
                }
                try {
                    monitor.subTask(Messages.IpsBuilder_building + ipsSrcFile.getName());
                    buildIpsSrcFile(ipsArtefactBuilderSet, getIpsProject(), ipsSrcFile, buildStatus, monitor);
                    monitor.worked(1);
                } catch (Exception e) {
                    buildStatus.add(new IpsStatus(e));
                }
            }
        } catch (CoreException e) {
            buildStatus.add(new IpsStatus(e));
        } finally {
            monitor.done();
        }
        long end = System.currentTimeMillis();
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Full build finished. Duration: " + (end - begin)); //$NON-NLS-1$
        }
        return buildStatus;
    }

    @Override
    protected void clean(IProgressMonitor monitor) throws CoreException {
        IIpsPackageFragmentRoot[] roots = getIpsProject().getIpsPackageFragmentRoots();
        for (int i = 0; i < roots.length; i++) {
            if (monitor.isCanceled()) {
                return;
            }
            if (!roots[i].isBasedOnSourceFolder()) {
                continue;
            }
            IFolder destination = roots[i].getArtefactDestination(true);
            if (destination == null) {
                continue;
            }
            if (destination.exists()) {
                removeDerivedResources(destination, monitor);
            }
        }
    }

    /**
     * Only the resource (file, folder) that is actually derived will be deleted. So if a user
     * chooses to place a non derived resource in the destination folder it will not be deleted.
     * Accordingly all folders in the folder hierarchy starting from the folder that contains the
     * derived resource will not be deleted.
     */
    private void removeDerivedResources(IFolder folder, IProgressMonitor monitor) throws CoreException {
        IResource[] members = folder.members();
        for (IResource member : members) {
            if (monitor.isCanceled()) {
                return;
            }
            if (member.exists()) {
                if (member.getType() == IResource.FILE && member.isDerived()) {
                    member.delete(true, monitor);
                    continue;
                }
                if (member.getType() == IResource.FOLDER) {
                    IFolder folderMember = (IFolder)member;
                    removeDerivedResources(folderMember, monitor);
                    if (folderMember.members().length == 0 && folderMember.isDerived()) {
                        folderMember.delete(true, monitor);
                    }
                }
            }
        }
    }

    private void removeEmptyFolders(IFolder parent, boolean removeThisParent) throws CoreException {
        if (parent == null || !parent.exists()) {
            return;
        }
        IResource[] members = parent.members();
        if (removeThisParent && members.length == 0) {
            parent.delete(true, null);
            return;
        }
        for (IResource member : members) {
            if (member.getType() == IResource.FOLDER) {
                removeEmptyFolders((IFolder)member, true);
            }
        }
    }

    private Set<IDependency> getDependencySetForProject(IIpsProject project,
            Map<IIpsProject, Set<IDependency>> buildCandidatesForProjectMap) {
        Set<IDependency> buildCandidatesSet = buildCandidatesForProjectMap.get(project);
        if (buildCandidatesSet == null) {
            buildCandidatesSet = new HashSet<IDependency>(1000);
            buildCandidatesForProjectMap.put(project, buildCandidatesSet);
        }
        return buildCandidatesSet;
    }

    /**
     * Incremental build generates Java source files for all PdObjects that have been changed.
     */
    private void incrementalBuild(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            MultiStatus buildStatus,
            IProgressMonitor monitor) {
        if (TRACE_BUILDER_TRACE) {
            System.out.println("Incremental build started."); //$NON-NLS-1$
        }

        try {
            IResourceDelta delta = getDelta(getProject());
            IncBuildVisitor visitor = new IncBuildVisitor();
            delta.accept(visitor);
            Map<IIpsProject, Set<IDependency>> dependenciesForProjectsMap = new HashMap<IIpsProject, Set<IDependency>>(
                    10);
            int numberOfBuildCandidates = collectDependenciesForIncrementalBuild(visitor.changedAndAddedIpsSrcFiles,
                    visitor.removedIpsSrcFiles, dependenciesForProjectsMap)
                    + visitor.removedIpsSrcFiles.size()
                    + visitor.changedAndAddedIpsSrcFiles.size();
            monitor.beginTask("build incremental", numberOfBuildCandidates); //$NON-NLS-1$
            for (IIpsSrcFile iIpsSrcFile : visitor.removedIpsSrcFiles) {
                if (monitor.isCanceled()) {
                    break;
                }
                IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
                monitor.subTask(Messages.IpsBuilder_deleting + ipsSrcFile.getName());
                applyBuildCommand(ipsArtefactBuilderSet, buildStatus, new DeleteArtefactBuildCommand(ipsSrcFile),
                        monitor);
                updateDependencyGraph(buildStatus, ipsSrcFile);
                monitor.worked(1);
            }

            for (IIpsSrcFile iIpsSrcFile : visitor.changedAndAddedIpsSrcFiles) {
                if (monitor.isCanceled()) {
                    break;
                }
                IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
                monitor.subTask(Messages.IpsBuilder_building + ipsSrcFile.getName());
                buildIpsSrcFile(ipsArtefactBuilderSet, getIpsProject(), ipsSrcFile, buildStatus, monitor);
                updateDependencyGraph(buildStatus, ipsSrcFile);
                monitor.worked(1);
            }

            for (IIpsProject ipsProject : dependenciesForProjectsMap.keySet()) {
                if (monitor.isCanceled()) {
                    break;
                }
                if (!ipsProject.equals(getIpsProject())) {
                    if (!checkIpsProjectBeforeBuild(ipsProject.getProject(), ipsProject)) {
                        continue;
                    }
                }
                Set<IDependency> dependencySet = dependenciesForProjectsMap.get(ipsProject);

                /*
                 * Dependent IPS object can be located in a different project which can have a
                 * different artefact builder set therefore the builder set needs to be determined
                 * for each project at this point.
                 */
                ipsArtefactBuilderSet = getBuilderSetReInitialisedIfNecessary(ipsProject);
                Set<QualifiedNameType> alreadyBuild = new HashSet<QualifiedNameType>(dependencySet.size());
                MultiStatus currentBuildStatus = createInitialMultiStatus();
                try {
                    if (!ipsProject.equals(getIpsProject())) {
                        beforeBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, INCREMENTAL_BUILD);
                        applyBuildCommand(ipsArtefactBuilderSet, currentBuildStatus, new BeforeBuildProcessCommand(
                                INCREMENTAL_BUILD, ipsProject), monitor);
                    }
                    for (IDependency dependency : dependencySet) {
                        if (monitor.isCanceled()) {
                            break;
                        }
                        QualifiedNameType buildCandidateId = dependency.getSource();
                        if (alreadyBuild.contains(buildCandidateId)) {
                            continue;
                        }
                        alreadyBuild.add(buildCandidateId);
                        IIpsObject ipsObject = ipsProject.findIpsObject(buildCandidateId);
                        if (ipsObject == null) {
                            continue;
                        }
                        monitor.subTask(Messages.IpsBuilder_building + dependency);
                        buildIpsSrcFile(ipsArtefactBuilderSet, ipsProject, ipsObject.getIpsSrcFile(),
                                currentBuildStatus, monitor);
                        updateDependencyGraph(currentBuildStatus, ipsObject.getIpsSrcFile());
                        monitor.worked(1);
                    }
                } catch (Exception e) {
                    currentBuildStatus.add(new IpsStatus(IStatus.ERROR, NLS.bind(
                            Messages.IpsBuilder_msgExceptionWhileBuildingDependentProjects, ipsProject.getName()), e));
                } finally {
                    if (!ipsProject.equals(getIpsProject())) {
                        applyBuildCommand(ipsArtefactBuilderSet, currentBuildStatus, new AfterBuildProcessCommand(
                                INCREMENTAL_BUILD, ipsProject), monitor);
                        afterBuildForBuilderSet(ipsArtefactBuilderSet, buildStatus, INCREMENTAL_BUILD);
                        if (currentBuildStatus.getSeverity() != IStatus.OK) {
                            ipsProject.reinitializeIpsArtefactBuilderSet();
                        }
                    }
                }
                if (!currentBuildStatus.isOK()) {
                    buildStatus.add(currentBuildStatus);
                }
            }
        } catch (Exception e) {
            buildStatus.add(new IpsStatus(e));
        } finally {
            monitor.done();
            if (TRACE_BUILDER_TRACE) {
                System.out.println("Incremental build finished."); //$NON-NLS-1$
            }
        }
    }

    private void updateMarkers(MultiStatus buildStatus, IIpsObject object) {
        if (object == null) {
            return;
        }
        IResource resource = object.getEnclosingResource();
        if (!resource.exists()) {
            return;
        }
        try {

            MessageList list = object.validate(object.getIpsProject());
            createMarkersFromMessageList(resource, list, IpsPlugin.PROBLEM_MARKER);
        } catch (Exception e) {
            buildStatus.add(new IpsStatus("An exception occurred during marker updating for " + object, e)); //$NON-NLS-1$
        }
    }

    private void createMarkersFromMessageList(IResource resource, MessageList list, String markerType)
            throws CoreException {

        resource.deleteMarkers(IpsPlugin.PROBLEM_MARKER, true, IResource.DEPTH_ZERO);
        for (int i = 0; i < list.size(); i++) {
            Message msg = list.getMessage(i);
            IMarker marker = resource.createMarker(markerType);
            updateMarker(marker, msg.getText(), getMarkerSeverity(msg));
        }
    }

    private void updateMarker(IMarker marker, String text, int severity) throws CoreException {
        marker.setAttributes(new String[] { IMarker.MESSAGE, IMarker.SEVERITY }, new Object[] { text,
                new Integer(severity) });
    }

    private int getMarkerSeverity(Message msg) {
        int msgSeverity = msg.getSeverity();
        if (msgSeverity == Message.ERROR) {
            return IMarker.SEVERITY_ERROR;
        } else if (msgSeverity == Message.WARNING) {
            return IMarker.SEVERITY_WARNING;
        } else if (msgSeverity == Message.INFO) {
            return IMarker.SEVERITY_INFO;
        }
        throw new RuntimeException("Unknown severity " + msgSeverity); //$NON-NLS-1$
    }

    /**
     * Builds the indicated file and updates its markers.
     */
    private IIpsObject buildIpsSrcFile(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            IIpsProject ipsProject,
            IIpsSrcFile file,
            MultiStatus buildStatus,
            IProgressMonitor monitor) throws CoreException {

        if (!file.isContentParsable()) {
            IMarker marker = file.getCorrespondingResource().createMarker(IpsPlugin.PROBLEM_MARKER);
            marker.setAttribute(IMarker.MESSAGE, Messages.IpsBuilder_ipsSrcFileNotParsable);
            marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
            return null;
        }
        IIpsObject ipsObject = file.getIpsObject();
        MultiStatus newStatus = createInitialMultiStatus();
        applyBuildCommand(ipsArtefactBuilderSet, newStatus, new BuildArtefactBuildCommand(file), monitor);
        if (!newStatus.isOK()) {
            fillMultiStatusWithMessageList(newStatus, ipsObject.validate(ipsProject));
            buildStatus.add(newStatus);
        }
        updateMarkers(buildStatus, ipsObject);
        return ipsObject;
    }

    private void fillMultiStatusWithMessageList(MultiStatus status, MessageList list) {
        for (int i = 0; i < list.size(); i++) {
            Message msg = list.getMessage(i);
            status.add(new IpsStatus(getMarkerSeverity(msg), msg.getText(), null));
        }
    }

    private void updateDependencyGraph(MultiStatus buildStatus, IIpsSrcFile ipsSrcFile) {
        try {
            DependencyGraph graph = ((IpsModel)ipsSrcFile.getIpsProject().getIpsModel()).getDependencyGraph(ipsSrcFile
                    .getIpsProject());
            graph.update(ipsSrcFile.getQualifiedNameType());
        } catch (CoreException e) {
            buildStatus.add(new IpsStatus("An error occurred while trying to update the " + //$NON-NLS-1$
                    "dependency graph for the IpsSrcFile: " + ipsSrcFile, e)); //$NON-NLS-1$
        }
    }

    private int collectDependenciesForIncrementalBuild(List<IIpsSrcFile> addedOrChangesIpsSrcFiles,
            List<IIpsSrcFile> removedIpsSrcFiles,
            Map<IIpsProject, Set<IDependency>> dependenciesForProjectsMap) throws CoreException {

        IIpsProject ipsProject = getIpsProject();
        Counter counter = new Counter(0);
        for (IIpsSrcFile iIpsSrcFile : addedOrChangesIpsSrcFiles) {
            IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
            collectDependenciesForProject(ipsSrcFile.getQualifiedNameType(), ipsProject, new HashSet<IIpsProject>(),
                    dependenciesForProjectsMap, counter, false);
        }
        for (IIpsSrcFile iIpsSrcFile : removedIpsSrcFiles) {
            IpsSrcFile ipsSrcFile = (IpsSrcFile)iIpsSrcFile;
            // TODO do we still need to find out if the file is in the ips projects roots?
            IIpsPackageFragmentRoot[] roots = ipsSrcFile.getIpsProject().getSourceIpsPackageFragmentRoots();
            for (IIpsPackageFragmentRoot root : roots) {
                if (ipsSrcFile.getIpsPackageFragment().getRoot().equals(root)) {
                    collectDependenciesForProject(ipsSrcFile.getQualifiedNameType(), ipsProject,
                            new HashSet<IIpsProject>(), dependenciesForProjectsMap, counter, false);
                }
            }
        }
        return counter.getCounts();
    }

    private void collectDependenciesForProject(QualifiedNameType root,
            IIpsProject ipsProject,
            Set<IIpsProject> visitedProjects,
            Map<IIpsProject, Set<IDependency>> dependenciesForProjectMap,
            Counter counter,
            boolean searchInstanceOfDependencyOnly) throws CoreException {

        // build object of dependent projects only if the dependent project can be build ...
        if (!ipsProject.canBeBuild()) {
            return;
        }

        IpsModel model = (IpsModel)IpsPlugin.getDefault().getIpsModel();
        DependencyGraph graph = model.getDependencyGraph(ipsProject);
        if (graph == null) {
            return;
        }
        /*
         * When collecting dependencies it is necessary to know if the builder set has any
         * properties that influences the dependency management.
         */
        IIpsArtefactBuilderSet ipsArtefactBuilderSet = model.getIpsArtefactBuilderSet(ipsProject, false);
        collectDependencies(ipsArtefactBuilderSet, graph, dependenciesForProjectMap, root, counter,
                searchInstanceOfDependencyOnly);
        collectDependenciesWithinDependantProjects(root, ipsProject, visitedProjects, dependenciesForProjectMap,
                counter, searchInstanceOfDependencyOnly);
    }

    private void collectDependenciesWithinDependantProjects(QualifiedNameType root,
            IIpsProject ipsProject,
            Set<IIpsProject> visitedProjects,
            Map<IIpsProject, Set<IDependency>> dependenciesForProjectMap,
            Counter counter,
            boolean searchInstanceOfDependencyOnly) throws CoreException {

        visitedProjects.add(ipsProject);
        IIpsProject[] dependantProjects = ipsProject.findReferencingProjects(false);
        for (int i = 0; i < dependantProjects.length && !visitedProjects.contains(dependantProjects[i]); i++) {
            collectDependenciesForProject(root, dependantProjects[i], visitedProjects, dependenciesForProjectMap,
                    counter, searchInstanceOfDependencyOnly);
        }
        return;
    }

    private void collectDependencies(IIpsArtefactBuilderSet ipsArtefactBuilderSet,
            DependencyGraph graph,
            Map<IIpsProject, Set<IDependency>> dependenciesForProjectMap,
            QualifiedNameType source,
            Counter counter,
            boolean searchInstanceOfDependencyOnly) throws CoreException {

        Set<IDependency> dependencySet = getDependencySetForProject(graph.getIpsProject(), dependenciesForProjectMap);
        IDependency[] dependencies = graph.getDependants(source);

        for (int i = 0; i < dependencies.length; i++) {
            if (!dependencySet.contains(dependencies[i])) {

                if (searchInstanceOfDependencyOnly) {
                    if (dependencies[i].getType().equals(DependencyType.INSTANCEOF)) {
                        dependencySet.add(dependencies[i]);
                        counter.increment();
                    }
                    continue;
                }

                dependencySet.add(dependencies[i]);
                counter.increment();
                if (dependencies[i].getType().equals(DependencyType.SUBTYPE)) {
                    collectDependencies(ipsArtefactBuilderSet, graph, dependenciesForProjectMap,
                            dependencies[i].getSource(), counter, false);
                    collectDependenciesWithinDependantProjects(dependencies[i].getSource(), graph.getIpsProject(),
                            new HashSet<IIpsProject>(100), dependenciesForProjectMap, counter, false);
                    continue;
                }

                if (dependencies[i].getType().equals(DependencyType.REFERENCE_COMPOSITION_MASTER_DETAIL)
                        && ipsArtefactBuilderSet.containsAggregateRootBuilder()) {
                    collectDependencies(ipsArtefactBuilderSet, graph, dependenciesForProjectMap,
                            dependencies[i].getSource(), counter, false);
                    collectDependenciesWithinDependantProjects(dependencies[i].getSource(), graph.getIpsProject(),
                            new HashSet<IIpsProject>(100), dependenciesForProjectMap, counter, false);
                    continue;
                }
                if (dependencies[i].getType().equals(DependencyType.REFERENCE)
                        || dependencies[i].getType().equals(DependencyType.DATATYPE)) {
                    collectDependencies(ipsArtefactBuilderSet, graph, dependenciesForProjectMap,
                            dependencies[i].getSource(), counter, true);
                    collectDependenciesWithinDependantProjects(dependencies[i].getSource(), graph.getIpsProject(),
                            new HashSet<IIpsProject>(100), dependenciesForProjectMap, counter, true);
                }
            }
        }
        return;
    }

    private static class Counter {

        private int counts = 0;

        private Counter(int offSet) {
            counts = offSet;
        }

        private void increment() {
            counts++;
        }

        private int getCounts() {
            return counts;
        }
    }

    /**
     * ResourceDeltaVisitor for the incremental build.
     */
    private class IncBuildVisitor implements IResourceDeltaVisitor {

        private IFolder[] outputFolders;
        private List<IIpsSrcFile> removedIpsSrcFiles = new ArrayList<IIpsSrcFile>(100);
        private List<IIpsSrcFile> changedAndAddedIpsSrcFiles = new ArrayList<IIpsSrcFile>(100);

        private IncBuildVisitor() throws CoreException {
            outputFolders = getIpsProject().getOutputFolders();
        }

        /**
         * Checks if the provided resource is the java output folder resource or the IpsProject
         * output folder resource.
         */
        private boolean ignoredResource(IResource resource) throws CoreException {
            IPath outPutLocation = getIpsProject().getJavaProject().getOutputLocation();
            IPath resourceLocation = resource.getFullPath();
            if (outPutLocation.equals(resourceLocation)) {
                return true;
            }
            for (IFolder outputFolder : outputFolders) {
                if (outputFolder.getFullPath().equals(resourceLocation)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public boolean visit(IResourceDelta delta) throws CoreException {
            IResource resource = delta.getResource();
            if (resource == null || resource.getType() == IResource.PROJECT) {
                return true;
            }
            /*
             * Resources in the output folders of the ipsProject and the assigned java project are
             * ignored.
             */
            if (ignoredResource(resource)) {
                return false;
            }

            // only interested in IpsSrcFile changes
            IIpsElement element = IpsPlugin.getDefault().getIpsModel().getIpsElement(resource);
            if (!(element instanceof IIpsSrcFile)) {
                return true;
            }
            IIpsSrcFile ipsSrcFile = (IIpsSrcFile)element;
            switch (delta.getKind()) {
                case IResourceDelta.ADDED:
                    if (element.exists()) {
                        changedAndAddedIpsSrcFiles.add(ipsSrcFile);
                    }
                    return true;
                case IResourceDelta.REMOVED:
                    removedIpsSrcFiles.add(ipsSrcFile);
                    break;
                case IResourceDelta.CHANGED: {
                    // skip changes, not caused by content changes,
                    if (delta.getFlags() != 0 && element.exists()) {
                        changedAndAddedIpsSrcFiles.add(ipsSrcFile);
                        return true;
                    }
                }
                    break;
            }
            return true;
        }
    }

    /**
     * The applyBuildCommand method of this class uses this interface.
     */
    private interface BuildCommand {
        public void build(IIpsArtefactBuilder builder, MultiStatus status) throws CoreException;
    }

    private class BeforeBuildProcessCommand implements BuildCommand {

        private int buildKind;
        private IIpsProject ipsProject;

        public BeforeBuildProcessCommand(int buildKind, IIpsProject ipsProject) {
            this.buildKind = buildKind;
            this.ipsProject = ipsProject;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) throws CoreException {
            if (TRACE_BUILDER_TRACE) {
                System.out.println("BeforeBuildProcessCommand, BuilderName: " //$NON-NLS-1$
                        + (builder != null ? builder.getName() : null) + " , BuilderObjectId: " //$NON-NLS-1$
                        + System.identityHashCode(builder) + ", Project name: " //$NON-NLS-1$
                        + (ipsProject != null ? ipsProject.getName() : null));
            }
            if (builder != null) {
                builder.beforeBuildProcess(ipsProject, buildKind);
            } else {
                throw new CoreException(new Status(IStatus.ERROR, IpsPlugin.PLUGIN_ID,
                        "Builder is assert to be not null")); //$NON-NLS-1$
            }
        }

        @Override
        public String toString() {
            return "BeforeBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
        }

    }

    private class AfterBuildProcessCommand implements BuildCommand {

        private int buildKind;
        private IIpsProject ipsProject;

        public AfterBuildProcessCommand(int buildKind, IIpsProject ipsProject) {
            this.buildKind = buildKind;
            this.ipsProject = ipsProject;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) throws CoreException {
            if (TRACE_BUILDER_TRACE) {
                System.out.println("AfterBuildProcessCommand, BuilderName: " //$NON-NLS-1$
                        + (builder != null ? builder.getName() : null) + " , BuilderObjectId: " //$NON-NLS-1$
                        + System.identityHashCode(builder) + ", Project name: " //$NON-NLS-1$
                        + (ipsProject != null ? ipsProject.getName() : null));
            }
            if (builder != null) {
                builder.afterBuildProcess(ipsProject, buildKind);
            } else {
                throw new CoreException(new Status(IStatus.ERROR, IpsPlugin.PLUGIN_ID,
                        "Builder is assert to be not null")); //$NON-NLS-1$
            }
        }

        @Override
        public String toString() {
            return "AfterBuildProcessCmd[kind=" + buildKind + "]"; //$NON-NLS-1$ //$NON-NLS-2$
        }
    }

    private static class BuildArtefactBuildCommand implements BuildCommand {

        private IIpsSrcFile ipsSrcFile;

        public BuildArtefactBuildCommand(IIpsSrcFile ipsSrcFile) {
            this.ipsSrcFile = ipsSrcFile;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) throws CoreException {
            if (builder.isBuilderFor(ipsSrcFile)) {
                long begin = 0;
                try {
                    if (TRACE_BUILDER_TRACE) {
                        begin = System.currentTimeMillis();
                        System.out.println(builder.getName() + ": Start building " + ipsSrcFile); //$NON-NLS-1$
                    }
                    builder.beforeBuild(ipsSrcFile, status);
                    builder.build(ipsSrcFile);
                } finally {
                    builder.afterBuild(ipsSrcFile);
                    if (TRACE_BUILDER_TRACE) {
                        System.out.println(builder.getName() + ": Finished building " + ipsSrcFile + ". Duration: " //$NON-NLS-1$ //$NON-NLS-2$
                                + (System.currentTimeMillis() - begin));
                    }
                }
            }
        }

        @Override
        public String toString() {
            return "Build file " + ipsSrcFile; //$NON-NLS-1$
        }
    }

    private static class DeleteArtefactBuildCommand implements BuildCommand {

        private IIpsSrcFile toDelete;

        public DeleteArtefactBuildCommand(IIpsSrcFile toDelete) {
            this.toDelete = toDelete;
        }

        @Override
        public void build(IIpsArtefactBuilder builder, MultiStatus status) throws CoreException {
            if (builder.isBuilderFor(toDelete)) {
                builder.delete(toDelete);
            }
        }

        @Override
        public String toString() {
            return "Delete file " + toDelete; //$NON-NLS-1$
        }

    }

}
