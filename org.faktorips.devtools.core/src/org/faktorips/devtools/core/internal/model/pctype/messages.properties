PersistentAssociationInfo_joinColumnName=join column name
PersistentAssociationInfo_joinTableName=join table name
PersistentAssociationInfo_msgIsInvalid={0} is invalid.
PersistentAssociationInfo_msgJoinTableNameExceedsMaximumLength=The join table name length exceeds the maximum length defined in the persistence options. The join table name length is {0} and the maximum length is {1}.
PersistentAssociationInfo_msgLazyFetchNotSupported=The lazy fetch type is not supported on single valued associations sides.
PersistentAssociationInfo_msgMaxLengthExceeds=The {0} length exceeds the maximum length defined in the persistence options. The length is {1} and the maximum column length is {2}.
PersistentAssociationInfo_msgMustBeEmpty=The {0} must be empty
PersistentAssociationInfo_msgMustNotBeEmpty=The {0} must not be empty
PersistentAssociationInfo_msgOwningSideManyToManyMarkedOnBothSides=The owning side of the relationship is marked on both sides.
PersistentAssociationInfo_msgOwningSideManyToManyNotAllowed=Must not be marked as owning side of many-to-many association because an join table is not required.
PersistentAssociationInfo_msgOwningSideMissing=One association must be marked as the owning side of the relationship.
PersistentAssociationInfo_msgTransientMismatch=If the association is marked as transient or if the persistent type is not entity, then the target side must also be marked as transient and vise versa.
PersistentAssociationInfo_sourceColumnName=source column name
PersistentAssociationInfo_tagetColumnName=target column name

PersistentAttributeInfo_msgColumnNameLengthExceedsMaximumLength=The column name length exceeds the maximum length defined in the persistence options. The column name length is {0} and the maximum defined length is {1}.
PersistentAttributeInfo_msgColumnNameMustBeEmpty=The column name must be empty, because the attribute is derived.
PersistentAttributeInfo_msgColumnNameMustNotContainWhitespaceCharacters=The column name must not contain whitespaces.
PersistentAttributeInfo_msgColumnPrecisionExceedsTheLimit=The column precision exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgColumnScaleExceedsTheLimit=The column scale exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgColumnSizeExceedsTheLimit=The column size exceeds the limit [{0}..{1}]
PersistentAttributeInfo_msgEmptyColumnName=Empty column name.
PersistentInfo_msgIndexNameIsInvalid={0} is not a valid name for an index.

PersistentTypeInfo_msgDiscriminatorAlreadyDefined=The discriminator value "{0}" is already defined in the supertype {1}
PersistentTypeInfo_msgDiscriminatorColumnNameIsInvalid=The discriminator column name is invalid.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedBecauseMappedSuperclass=The discriminator definition is not allowed here because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedNotRootEntity=The discriminator definition is not allowed here because this type is not the root entity.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedTypeNotDefDiscrColumn=The discriminator definition is not allowed here because this type doesn't define the discriminator column.
PersistentTypeInfo_msgDiscriminatorMustBeDefinedInTheRootEntity=The discriminator must be defined in the root entity {0}.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmpty=The discriminator value must be empty if the root entity doesn't define a discriminator column or the type is abstract.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmptyBecauseMappedSuperclass=The discriminator value must be empty because this type is marked as mapped superclass.
PersistentTypeInfo_msgDiscriminatorValueMustNotBeEmpty=The discriminator value must not be empty if the root entity defines the dicriminator column and the type is not abstract.
PersistentTypeInfo_msgDiscriminatorValueNotConform=The discriminator value does not conform to the specified descriminator datatype.
PersistentTypeInfo_msgDuplicateColumnName=Duplicate column name {0}
PersistentTypeInfo_msgFoundDuplicateColumnNameIn=. Found duplicate name in {0}.
PersistentTypeInfo_msgInvalidInheritanceStratedyCombination=Invalid combination of inheritance strategies. Resolve by changing strategy for either {0} ({1}) or {2} ({3})
PersistentTypeInfo_msgTableNameExceedsMaximumLength=The table name length exceeds the maximum length defined in the persistence options. The table name length is {0} and the maximum length is {1}.
PersistentTypeInfo_msgTableNameInvalid=The table name is invalid
PersistentTypeInfo_msgTableNameMustBeEmptyBecauseNameDefinedInSupertypeShouldBeUsed=The table name must be empty because the table name defined in the super type should be used.
PersistentTypeInfo_msgTableNameMustBeEmptyMappedSuperclass=The table name must empty because the policy component type is marked as mapped superclass.
PersistentTypeInfo_msgTableNameMustBeEmptyNotRootEntityAndInhStrategyIs=The table name must be empty because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgTableNameOfRootEntityMustBeUsed=The table name of the root entity must be used because this is not the root entity and the inheritance strategy is: {0}
PersistentTypeInfo_msgUseTableDefInSupertypIsNotAllowed=No supertype specified, thus it is not possible to use the table defined in the supertyp.

PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmpty=For detail-to-master associations the inverse associations must not be empty
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmptyIfDerivedUnionHasInverse=The inverse must not be empty, if the derived union association specifies an inverse association.
PolicyCmptTypeAssociation_Association_msg_InverseOfMasterToDetailMustBeADetailToMaster=The inverse of a master-to-detail association must be a detail-to-master association.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalid=The matching association does not match this association
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForConfiguredType=For configured policy component type you must use the corresponding product component type.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForNotConfiguredType=The source of the matching association must be referenced by a parent of this policy component type.
PolicyCmptTypeAssociation_error_matchingAssociatonNotFound=Cannot find the matching association {0} in product component type {1}
PolicyCmptTypeAssociation_errorMsg_constrainedPropertyQualifiedMismatch=Property "qualified" must match with the overridden association.
PolicyCmptTypeAssociation_InverseOfDetailToMasterMustBeAMasterToDetail=The inverse of a detail-to-master association must be a master-to-detail association.
PolicyCmptTypeAssociation_sharedAssociation_invalidAssociationHost=For shared associations, the corresponding association in the supertype must be an inverse association of a derived union.
PolicyCmptTypeAssociation_sharedAssociation_noAssociationHost=The shared associations must have an association with the same name and target in supertype.

PolicyCmptTypeAttribute_msg_IllegalValueSetType=The value set type {0} is not allowed.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureIsMissing=The reference to the computation method signature is missing for attribute {0}\!
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureDoesNotExists=The specified computation method signature does not exist\!
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureHasADifferentDatatype=The computation method has a different datatype\!
PolicyCmptTypeAttribute_msg_defaultValueExtensibleEnumType=Values of extensible enum types are only acceptable as default value in product relevant attributes.
PolicyCmptTypeAttribute_TypeOfOverwrittenAttributeCantBeChanged=The type of the overwritten attribute can only be changed from "derived (computet on each call)" to "changeable"\!

PolicyCmptType_msgSubtypeConfigurableWhenSupertypeConfigurable=The super type is configurable which means this type needs to be configurable as well.
PolicyCmptType_msgDuplicateRuleName=Another validation rule exists with the same name in this type or within the supertype hierarchy.
PolicyCmptType_msgInverseDerivedUnionNotSepcified=No inverse association defined for subset derived union "{0}" in type "{1}"
PolicyCmptType_msgRuleMethodNameConflict=The name of this validation rule: {0} conflicts with the name of a method within this type or within the supertype hierarchy.
PolicyCmptType_msg_ProductCmptTypeNameMissing=The product component type name is missing.
PolicyCmptType_productCmptType=Product component type
PolicyCmptType_TheTypeDoesNotConfigureThisType=The type {0} does not configure this type.
PolicyCmptType_caption=Policy Component Type

Association_msg_InverseAssociationInconsistentWithDerivedUnion=The inverse association is inconsistent with the derived union {0}.
Association_msg_AssociationNotFoundInTarget=The association {0} does not exist in the target {1}.
Association_msg_InverseAssociationMismatch=The inverse relation does not specify this relation as it's inverse one\!
Association_msg_InverseAssociationMustBeMarkedAsDerivedUnionToo=The association and it's inverse association must both be marked as derived union.
Association_msg_InverseAssociationMustBeOfTypeAssociation=The inverse association of an association must be an association\!
Association_msg_DetailToMasterAssociationMustHaveMaxCardinality1=A detail-to-master association must have a max cardinality of 1.

ValidationRule_msg_InvalidMarkerId=The marker ids {0} do not exist in "{1}".
ValidationRule_msgFunctionNotExists=Function {0} does not exists.
ValidationRule_msgIgnored=The rule is applied in all business functions, this information is ignored.
ValidationRule_msgUndefinedAttribute=The specified attribute is not defined for the policy component type of this rule.
ValidationRule_msgOneBusinessFunction=If the validation rule is not applied to all business functions, at least one business function must be assigned.
ValidationRule_msgCodeShouldBeProvided=A message code should be provided to make testing of the rule easier for example.
ValidationRule_ConstantAttributesCantBeValidated=Constant attributes can't be validated\!
ValidationRule_msgDuplicateEntries=Duplicate entries.
ValidationRule_msgNoNewlineAllowed=No newline allowed in message text. Found in {0} message.
ValidationRule_msgValueSetRule=The value set of this attribute needs to be either a range or an enumeration to enable this rule. 
ValidationRuleMessageText_warning_invalidParameter=The parameter {0} used in the {1} text is not used in the text of the default language.

Attribute_msgAttributeCantBeProductRelevantIfTypeIsNot=The attribute can only be configured, if the owning type is configurable.
Attribute_proposalForMsgCode=INVALID_{0}
Attribute_proposalForRuleName=check{0}

Attribute_msg_Overwritten_datatype_different=The datatype is different to the datatype of the overwritten attribute\!
MarkerEnumUtil_invalidMarkerEnum=<invalid marker enum>
