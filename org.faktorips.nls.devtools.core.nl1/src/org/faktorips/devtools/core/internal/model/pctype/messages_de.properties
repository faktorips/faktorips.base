PersistentAssociationInfo_joinColumnName=Join-Spaltenname
PersistentAssociationInfo_joinTableName=Join-Tabellenname
PersistentAssociationInfo_msgIsInvalid={0} ist ung\u00FCltig.
PersistentAssociationInfo_msgJoinTableNameExceedsMaximumLength=Der Join-Tabellenname ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAssociationInfo_msgLazyFetchNotSupported=Lazy Fetching wird nicht bei "toOne"-Assoziationen unterstützt.
PersistentAssociationInfo_msgMaxLengthExceeds=Die Länge vom {0} ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAssociationInfo_msgMustBeEmpty={0} darf nicht gef\u00FCllt sein
PersistentAssociationInfo_msgMustNotBeEmpty={0} muss gef\u00FCllt sein
PersistentAssociationInfo_msgOwningSideManyToManyMarkedOnBothSides=Beide Seiten der Beziehung sind als Eigentümer markiert.
PersistentAssociationInfo_msgOwningSideManyToManyNotAllowed=Darf nicht als Eigentümer der Beziehung markiert werden, da eine Join-Tabelle nicht benötigt ist.
PersistentAssociationInfo_msgOwningSideMissing=Eine Seite der Beziehung muss als Eigentümer markiert werden.
PersistentAssociationInfo_msgTransientMismatch=Wenn die Target-Seite der Assoziation oder die Target-Entity als transient gekennzeichnet ist, muss diese Seite ebenfalls als transient gekennzeichnet werden und umgekehrt.
PersistentAssociationInfo_sourceColumnName=Source-Spaltenname
PersistentAssociationInfo_tagetColumnName=Target-Spaltenname

PersistentAttributeInfo_msgColumnNameLengthExceedsMaximumLength=Die Länge des Spaltennamens ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentAttributeInfo_msgColumnNameMustBeEmpty=Der Spaltenname muss leer sein, da das Attribut abgeleitet ist.
PersistentAttributeInfo_msgColumnNameMustNotContainWhitespaceCharacters= Der Spaltenname darf keine Leerzeichen enthalten.
PersistentAttributeInfo_msgColumnPrecisionExceedsTheLimit=Spalten-Precision erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnScaleExceedsTheLimit=Spalten-Scale erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgColumnSizeExceedsTheLimit=Spalten-Size erreicht das Limit [{0}..{1}]
PersistentAttributeInfo_msgEmptyColumnName=Der Spaltenname ist leer.
PersistentInfo_msgIndexNameIsInvalid={0} ist kein g\u00FCltiger Name f\u00FCr einen Index.

PersistentTypeInfo_msgDiscriminatorAlreadyDefined=Der Diskriminatorwert "{0}" wird schon im Supertyp {1} verwendet.
PersistentTypeInfo_msgDiscriminatorColumnNameIsInvalid=Der Name der Diskriminator Spalte ist ung\u00FCltig.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedBecauseMappedSuperclass=Die Diskriminator Definition ist hier nicht erlaubt, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedNotRootEntity=Die Diskriminator Definition ist hier nicht erlaubt, da dies nicht die Root-Entity ist.
PersistentTypeInfo_msgDiscriminatorDefinitionNotAllowedTypeNotDefDiscrColumn=Die Diskriminator Definition ist hier nicht erlaubt, da hier keine Diskriminator Spalte definiert ist.
PersistentTypeInfo_msgDiscriminatorMustBeDefinedInTheRootEntity=Der Diskriminator muss in der Root-Entity {0} definiert werden.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmpty=Es darf kein Diskriminator Wert angegeben werden, wenn in der Root-Entity keine Diskriminator Spalte angegeben wurde oder der Typ abstrakt ist.
PersistentTypeInfo_msgDiscriminatorValueMustBeEmptyBecauseMappedSuperclass=Es darf kein Diskriminator Wert angegeben werden, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgDiscriminatorValueMustNotBeEmpty=Es muss ein Diskriminator Wert angegeben werden, wenn in der Root-Entity die Diskriminator Spalte angegeben wurde und der Typ nicht abstrakt ist.
PersistentTypeInfo_msgDiscriminatorValueNotConform=Der Diskriminator Wert passt nicht nicht zum angegebenen Datentyp.
PersistentTypeInfo_msgDuplicateColumnName=Doppelter Spaltenname {0}
PersistentTypeInfo_msgFoundDuplicateColumnNameIn=. Doppelter Name in {0}.
PersistentTypeInfo_msgInvalidInheritanceStratedyCombination=TODO joerg Ung\u00FCltig Kombination der Ableitungsstrategie, die Ableitungsstrategie muss angepasst werden in {0} ({1}) oder {2} ({3})
PersistentTypeInfo_msgTableNameExceedsMaximumLength=Die Länge des Tabellennamens ist länger als die maximal erlaubte Länge definiert in den Persistenz-Optionen. Die aktuelle Länge ist {0} und die maximal erlaubte Länge ist {1}.
PersistentTypeInfo_msgTableNameInvalid=Der Tabellenname ist ung\u00FCltig
PersistentTypeInfo_msgTableNameMustBeEmptyBecauseNameDefinedInSupertypeShouldBeUsed=Es darf kein Tabellenname angegeben werden, da der im Supertyp definierte Tabellenname verwendet werden soll.
PersistentTypeInfo_msgTableNameMustBeEmptyMappedSuperclass=Es darf kein Tabellenname angegeben werden, da der Entity-Typ als Mapped-Superclass definiert ist.
PersistentTypeInfo_msgTableNameMustBeEmptyNotRootEntityAndInhStrategyIs=Es darf kein Tabellenname angegeben werden, da dies die Root-Entity ist und die Ableitungsstrategie {0} ist
PersistentTypeInfo_msgTableNameOfRootEntityMustBeUsed=Es muss der Tabellenname der Root-Entity verwendet werden, da die Ableitungsstrategie {0} ist und dies nicht die Root-Entity ist.
PersistentTypeInfo_msgUseTableDefInSupertypIsNotAllowed=Kein Supertyp definiert, deswegen kann auch nicht der im Supertyp definierte Tabellenname verwendet werden.

PolicyCmptType_productCmptType=Produktbausteintyp
PolicyCmptType_msg_ProductCmptTypeNameMissing=Der Name des Produktbausteintyps fehlt.
PolicyCmptType_msgDuplicateRuleName=Es existiert eine weitere Validierungsregel mit dem selben Namen in diesem Typ (oder der Supertyp-Hierarchie). Regelnamen m\u00FCssen eindeutig sein.
PolicyCmptType_msgInverseDerivedUnionNotSepcified=Es wurde keine inverse Beziehung f\u00FCr die derived union "{0}" im Typ "{1}" gefunden
PolicyCmptType_msgRuleMethodNameConflict=Namenskonflikt f\u00FCr Regel "{0}". Der Name wird auch von einer Methode dieses Typs (oder der Supertyp-Hierarchie) verwendet.
PolicyCmptType_msgSubtypeConfigurableWhenSupertypeConfigurable=Der Supertyp ist konfigurierbar, deshalb muss dieser Typ auch konfigurierbar sein.
PolicyCmptType_TheTypeDoesNotConfigureThisType=Der Typ {0} konfiguriert diesen Typ nicht.
PolicyCmptType_caption=Vertragsteiltyp

PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmpty=F\u00FCr Detail-to-Master-Beziehungen muss eine inverse Beziehung angegeben werden.
PolicyCmptTypeAssociation_Association_msg_InverseAssociationMustNotBeEmptyIfDerivedUnionHasInverse=Es muss eine inverse Beziehung angegeben werden, wenn die abgeleitete Vereinigung eine inverse Beziehung besitzt.
PolicyCmptTypeAssociation_Association_msg_InverseOfMasterToDetailMustBeADetailToMaster=Die inverse Beziehung einer Master-to-Detail Beziehung muss eine Detail-to-Master Beziehung sein.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalid=Die entsprechende Beziehung referenziert diese Beziehung nicht.
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForConfiguredType=Für produktkonfigurierte Vertragsteilklassen muss die entsprechende Produktbausteinklasse verwendet werden.    
PolicyCmptTypeAssociation_error_MatchingAssociationInvalidSourceForNotConfiguredType=Die angegebene Produktbausteinklasse muss eine Vertragsteilklasse der Struktur konfigurieren.
PolicyCmptTypeAssociation_error_matchingAssociatonNotFound=Die Assoziation {0} in der Produktbausteinklsse {1} kann nicht gefunden werden.
PolicyCmptTypeAssociation_errorMsg_constrainedPropertyQualifiedMismatch=Die Eigenschaft "qualifiziert" muss wie in der überschriebenen Beziehung gesetzt sein.
PolicyCmptTypeAssociation_InverseOfDetailToMasterMustBeAMasterToDetail=Die inverse Beziehung einer Detail-to-Master Beziehung muss eine Master-to-Detail Beziehung sein.
PolicyCmptTypeAssociation_sharedAssociation_invalidAssociationHost=Die zu dieser gemeinsam genutzen Beziehung gehörende Beziehung in der Superklasse muss die Inverse Beziehung einer Abgeleiteten Vereinigung sein. 
PolicyCmptTypeAssociation_sharedAssociation_noAssociationHost=Zu einer gemeinsam genutzten Beziehung muss eine Beziehung mit gleichem Namen und Ziel in der Superklasse existieren.

PolicyCmptTypeAttribute_msg_IllegalValueSetType=Der Wertemengentyp {0} ist nicht erlaubt.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureDoesNotExists=Die angegebende Methode existiert nicht.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureHasADifferentDatatype=Die angegebende Methode hat einen anderen Datentyp wie dieses Attribut.
PolicyCmptTypeAttribute_msg_defaultValueExtensibleEnumType=Werte aus einem erweiterbaren Aufzählungstyp dürfen nur bei produktkonfigurierten Attributen als Vorbelegung ausgewählt werden.
PolicyCmptTypeAttribute_msg_ComputationMethodSignatureIsMissing=Es fehlt die Referenz auf die Methode, die das Attribut {0} berechnet.
PolicyCmptTypeAttribute_TypeOfOverwrittenAttributeCantBeChanged=Der Typ eines überschriebenen Attributes kann nur von "abgeleitet (Berechnung bei jedem Aufruf)" zu "änderbar" geändert werden.

Association_msg_InverseAssociationInconsistentWithDerivedUnion=Die inverse Beziehung ist inkonsistent mit der abgeleiteten Vereinigung {0}.
Association_msg_AssociationNotFoundInTarget=Die Beziehung {0} existiert im Zieltyp {1} nicht.
Association_msg_InverseAssociationMismatch=Die inverse Beziehung nennt nicht diese Beziehung als ihre inverse Beziehung\!
Association_msg_InverseAssociationMustBeMarkedAsDerivedUnionToo=Die inverse Beziehung dieser Beziehung ist nicht als abgeleitete Vereinigung markiert.
Association_msg_InverseAssociationMustBeOfTypeAssociation=Die inverse Beziehung einer Assoziation muss eine Assoziation sein\!
Association_msg_DetailToMasterAssociationMustHaveMaxCardinality1=Eine Detail-to-Master-Beziehung muss die maximale Kardinalit\u00E4t 1 haben.

ValidationRule_msg_InvalidMarkerId=Die Marker Ids {0} existieren nicht in "{1}".
ValidationRule_msgFunctionNotExists=Die Funktion {0} existiert nicht.
ValidationRule_msgIgnored=Diese Regel wird in allen Gesch\u00E4ftsvorf\u00E4llen angewandt, diese Information wird ignoriert.
ValidationRule_msgUndefinedAttribute=Das angegebene Attribut ist in dem Vertragsteiltyp dieser Regel nicht definiert.
ValidationRule_msgOneBusinessFunction=Die Gesch\u00E4ftsvorf\u00E4lle f\u00FCr die die Regel angewandt werden soll m\u00FCssen festgelegt werden.
ValidationRule_msgCodeShouldBeProvided=Die Regel sollte einen Message Code enthaltenen, das erleichert z. B. das Testen der Regel.
ValidationRule_ConstantAttributesCantBeValidated=Konstante Attribute k\u00F6nnen nicht validiert werden\! 
ValidationRule_msgDuplicateEntries=Doppelte Eintr\u00E4ge.
ValidationRule_msgNoNewlineAllowed=Im Meldungstext ist kein Zeilenumbruch erlaubt. (Text auf {0})
ValidationRule_msgValueSetRule=Diese Regel kann nur f\u00FCr ein Attribut verwendet werden, dessen Wertebereich entweder vom Typ Bereich oder Aufz\u00E4hlung ist.
ValidationRuleMessageText_warning_invalidParameter=Der Parameter {0} in der Sprache {1} wird nicht in der Standardsprache verwendet.

Attribute_msgAttributeCantBeProductRelevantIfTypeIsNot=Ein Attribut kann nicht konfiguriert werden, wenn der Typ nicht konfigurierbar ist.
Attribute_proposalForMsgCode={0}_UNGUELTIG
Attribute_proposalForRuleName=pruefe{0}

Attribute_msg_Overwritten_datatype_different=Der Datentyp ist unterschiedlich zum Datentyp des \u00FCberschriebenen Attributes\!
MarkerEnumUtil_invalidMarkerEnum=<ungültiges Marker Enum>
